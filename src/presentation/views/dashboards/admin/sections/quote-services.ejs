<%
/**
 * Quote Services Section
 * Itinerary management with days, subconcepts, and totals calculation
 * Structure: Each day has a title and multiple subconcepts with time scheduling
 */
%>

<div class="card border-0 shadow-sm">
    <div class="card-header bg-white border-bottom d-flex justify-content-between align-items-center">
        <h5 class="card-title mb-0">
            <i class="ti ti-list me-2"></i>Servicios del Itinerario
        </h5>
        <button type="button" class="btn btn-primary btn-sm" id="addDayBtn">
            <i class="ti ti-plus me-1"></i>Agregar D√≠a
        </button>
    </div>

    <div class="card-body">
        <!-- Alerts Container -->
        <div id="servicesAlerts"></div>

        <!-- Empty State -->
        <div id="emptyState" class="alert alert-info d-none align-items-start" role="alert">
            <i class="ti ti-info-circle me-2 fs-5 mt-1"></i>
            <div>
                <strong>Sin d√≠as agregados</strong>
                <p class="mb-0 mt-1">Presiona "+ Agregar D√≠a" para comenzar a construir el itinerario de servicios.</p>
            </div>
        </div>

        <!-- Services Table -->
        <div id="servicesTableContainer" class="d-none">
            <div class="table-responsive">
                <table class="table table-bordered table-hover align-middle" id="servicesTable">
                    <thead class="table-light">
                        <tr>
                            <th style="min-width: 100px;" class="text-center">
                                <i class="ti ti-settings me-1"></i>Acciones
                            </th>
                            <th style="min-width: 100px;" class="text-center">
                                <i class="ti ti-calendar me-1"></i>D√≠a
                            </th>
                            <th style="min-width: 300px;">
                                <i class="ti ti-file-text me-1"></i>Concepto
                            </th>
                            <th style="min-width: 150px;">
                                <i class="ti ti-car me-1"></i>Tipo Veh√≠culo
                            </th>
                            <th style="min-width: 120px;" class="text-end">
                                <i class="ti ti-currency-dollar me-1"></i>Precio Unit.
                            </th>
                            <th style="min-width: 300px;">
                                <i class="ti ti-notes me-1"></i>Notas
                            </th>
                            <th style="min-width: 140px;" class="text-end">
                                <i class="ti ti-receipt me-1"></i>Total D√≠a
                            </th>
                            <th style="min-width: 100px;" class="text-center">
                                <i class="ti ti-settings me-1"></i>Acciones
                            </th>
                        </tr>
                    </thead>
                    <tbody id="servicesTableBody">
                        <!-- Rows will be dynamically generated -->
                    </tbody>
                </table>
            </div>

            <!-- Totals Section -->
            <div class="totals-section mt-4">
                <div class="row align-items-center">
                    <!-- Add Day Button (Left Side) -->
                    <div class="col-lg-6 col-md-6 mb-3 mb-lg-0">
                        <button type="button" class="btn btn-primary" id="addDayBtnBottom">
                            <i class="ti ti-plus me-1"></i>Agregar D√≠a
                        </button>
                        <p class="text-muted small mb-0 mt-2">
                            <i class="ti ti-info-circle me-1"></i>
                            Agrega d√≠as al itinerario para organizar los servicios
                        </p>
                    </div>

                    <!-- Totals Card (Right Side) -->
                    <div class="col-lg-6 col-md-6">
                        <div class="card border">
                            <div class="card-body">
                                <table class="table table-sm mb-0">
                                    <tr>
                                        <td class="text-end border-0"><strong>Subtotal:</strong></td>
                                        <td class="text-end border-0 fs-6" id="subtotalDisplay">$0.00 MXN</td>
                                    </tr>
                                    <tr>
                                        <td class="text-end border-0"><strong>IVA (16%):</strong></td>
                                        <td class="text-end border-0 fs-6" id="ivaDisplay">$0.00 MXN</td>
                                    </tr>
                                    <tr class="border-top">
                                        <td class="text-end border-0 pt-2"><strong>TOTAL:</strong></td>
                                        <td class="text-end border-0 fs-5 fw-bold text-primary pt-2" id="totalDisplay">$0.00 MXN</td>
                                    </tr>
                                    <tr class="border-top">
                                        <td class="text-end border-0 pt-2">
                                            <strong>Costo por Persona:</strong>
                                            <br>
                                            <small class="text-muted" id="perPersonLabelDisplay">(0 personas)</small>
                                        </td>
                                        <td class="text-end border-0 fs-6 fw-bold text-info pt-2" id="perPersonDisplay">$0.00 MXN</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Save Indicator -->
        <div class="d-flex justify-content-between align-items-center mt-3">
            <div id="saveIndicator">
                <span class="badge bg-secondary">
                    <i class="ti ti-check me-1"></i>Sin cambios
                </span>
            </div>

            <div class="text-muted small">
                <i class="ti ti-info-circle me-1"></i>
                Los cambios se guardan autom√°ticamente cada 2 segundos
            </div>
        </div>
    </div>
</div>

<!-- Delete Day Modal -->
<div class="modal fade" id="deleteDayModal" tabindex="-1" aria-labelledby="deleteDayModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-danger text-white">
                <h5 class="modal-title" id="deleteDayModalLabel">
                    <i class="ti ti-alert-triangle me-2"></i>Confirmar Eliminaci√≥n de D√≠a
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>¬øEst√° seguro que desea eliminar <strong id="deleteDayText">D√≠a X</strong>?</p>
                <p class="text-muted small mb-0 mt-2">Esta acci√≥n eliminar√° el d√≠a completo con todos sus subconceptos. Los d√≠as posteriores se re-numerar√°n autom√°ticamente.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                    <i class="ti ti-x me-1"></i>Cancelar
                </button>
                <button type="button" class="btn btn-danger" id="confirmDeleteDayBtn">
                    <i class="ti ti-trash me-1"></i>Eliminar D√≠a
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Delete Subconcept Modal -->
<div class="modal fade" id="deleteSubconceptModal" tabindex="-1" aria-labelledby="deleteSubconceptModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-warning text-dark">
                <h5 class="modal-title" id="deleteSubconceptModalLabel">
                    <i class="ti ti-alert-triangle me-2"></i>Confirmar Eliminaci√≥n de Subconcepto
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>¬øEst√° seguro que desea eliminar este subconcepto?</p>
                <div class="alert alert-warning border mb-0">
                    <strong id="deleteSubconceptText" class="text-dark"></strong>
                </div>
                <p class="text-muted small mb-0 mt-2">El total del d√≠a se recalcular√° autom√°ticamente.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                    <i class="ti ti-x me-1"></i>Cancelar
                </button>
                <button type="button" class="btn btn-warning" id="confirmDeleteSubconceptBtn">
                    <i class="ti ti-trash me-1"></i>Eliminar Subconcepto
                </button>
            </div>
        </div>
    </div>
</div>

<style>
/* Service Items Table Styles */
#servicesTable input.form-control {
    font-size: 0.875rem;
}

#servicesTable .badge {
    font-size: 0.875rem;
    padding: 0.375rem 0.75rem;
}

/* Price display styles */
.tiny {
    font-size: 0.7rem;
}


/* Day total container with rowspan */
.day-total-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 1rem;
    min-height: 100px;
    background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
    border-radius: 0.5rem;
}

.day-total-display {
    font-size: 1.25rem;
    font-weight: 700;
    color: #f76b1c;
    transition: all 0.3s ease;
}

.day-total-display.text-success {
    color: #28a745 !important;
    transform: scale(1.1);
}

/* Time input styling */
.time-input {
    font-family: 'Courier New', monospace;
    font-weight: 600;
    text-align: center;
    letter-spacing: 1px;
}

.time-input.is-invalid {
    border-color: #dc3545;
    animation: shake 0.3s;
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

/* Day header row */
tr[data-row-type="day-header"] {
    background-color: #f8f9fa;
    border-top: 3px solid #f76b1c;
}

tr[data-row-type="day-header"] td {
    vertical-align: top;
    padding-top: 1rem;
}

/* Subconcept rows */
tr[data-row-type="subconcept"] {
    border-left: 3px solid rgba(247, 107, 28, 0.3);
}

/* Add subconcept button */
.add-subconcept-btn {
    border-style: dashed;
    border-width: 2px;
    transition: all 0.2s;
    font-size: 0.813rem;
}

.add-subconcept-btn:hover {
    border-style: solid;
    background-color: #f76b1c;
    color: white;
    border-color: #f76b1c;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(247, 107, 28, 0.2);
}

/* Day separator */
.day-separator {
    height: 1rem;
    background: linear-gradient(to bottom, #dee2e6 0%, transparent 100%);
}

/* Save indicator animations */
#saveIndicator .badge {
    transition: all 0.3s ease;
}

/* Input focus states */
#servicesTable input:focus {
    border-color: #f76b1c;
    box-shadow: 0 0 0 0.2rem rgba(247, 107, 28, 0.15);
}

/* Empty state */
#emptyState {
    margin: 2rem 0;
}

/* Totals card */
.totals-section .card {
    background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
}

/* Responsive adjustments */
@media (max-width: 768px) {
    #servicesTable th,
    #servicesTable td {
        font-size: 0.813rem;
    }

    #servicesTable input.form-control {
        font-size: 0.813rem;
        padding: 0.25rem 0.5rem;
    }

    .day-total-container {
        min-height: 60px;
        padding: 0.5rem;
    }

    .day-total-display {
        font-size: 1rem;
    }
}
</style>

<script>
(function() {
    'use strict';

    // ==================
    // GLOBAL STATE
    // ==================

    let serviceItemsData = {
        days: [],
        subtotal: 0,
        iva: 0,
        total: 0
    };

    let isDirty = false;
    let saveTimeout = null;
    let deleteContext = { type: null, dayIndex: null, subconceptIndex: null };
    let quoteNumberOfPeople = 1; // Store quote's total number of people

    const quoteId = '<%= typeof quoteId !== "undefined" ? quoteId : "" %>';
    const isNewQuote = quoteId === '' || quoteId === 'new';

    // Currency formatter
    const currencyFormatter = new Intl.NumberFormat('es-MX', {
        style: 'currency',
        currency: 'MXN',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    });

    // ==================
    // UTILITY FUNCTIONS
    // ==================

    /**
     * Format number as currency for display (with $ and commas)
     */
    function formatCurrency(value) {
        if (value === null || value === undefined || value === '') return '';
        const numValue = typeof value === 'string' ? parseFloat(value) : value;
        if (isNaN(numValue)) return '';
        return currencyFormatter.format(numValue);
    }

    /**
     * Parse formatted currency string back to number
     */
    function parseCurrency(formattedValue) {
        if (!formattedValue) return null;
        // Remove currency symbol, spaces, and commas
        const cleaned = formattedValue.replace(/[$,\s]/g, '');
        const numValue = parseFloat(cleaned);
        return isNaN(numValue) ? null : numValue;
    }

    function getAccessToken() {
        const cookies = document.cookie.split(';');

        for (let cookie of cookies) {
            const [name, value] = cookie.trim().split('=');
            if (name === 'accessToken') {
                return value;
            }
        }
        console.warn('accessToken not found in cookies!');

        // Try to get from localStorage as fallback
        const localToken = localStorage.getItem('accessToken');
        if (localToken) {
            return localToken;
        }

        // Try to get from sessionStorage as fallback
        const sessionToken = sessionStorage.getItem('accessToken');
        if (sessionToken) {
            return sessionToken;
        }

        return null;
    }

    function showAlert(containerId, message, type = 'danger') {
        const container = document.getElementById(containerId);
        if (!container) return;

        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${type} alert-dismissible fade show`;
        alertDiv.role = 'alert';
        alertDiv.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        `;
        container.appendChild(alertDiv);

        setTimeout(() => {
            if (alertDiv && alertDiv.parentNode) {
                alertDiv.remove();
            }
        }, 5000);
    }

    function clearAlerts(containerId) {
        const container = document.getElementById(containerId);
        if (container) {
            container.querySelectorAll('.alert').forEach(el => el.remove());
        }
    }

    // ==================
    // STATE MANAGEMENT
    // ==================

    function markDirty() {
        isDirty = true;
        showSaveIndicator('pending', 'Cambios pendientes');
    }

    function markClean() {
        isDirty = false;
    }

    function showSaveIndicator(state, text) {
        const indicator = document.getElementById('saveIndicator');
        if (!indicator) return;

        const badge = indicator.querySelector('.badge');
        if (!badge) return;

        badge.className = 'badge';

        switch(state) {
            case 'idle':
                badge.className = 'badge bg-secondary';
                badge.innerHTML = '<i class="ti ti-check me-1"></i>' + text;
                break;
            case 'pending':
                badge.className = 'badge bg-warning text-dark';
                badge.innerHTML = '<i class="ti ti-clock me-1"></i>' + text;
                break;
            case 'saving':
                badge.className = 'badge bg-info';
                badge.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>' + text;
                break;
            case 'saved':
                badge.className = 'badge bg-success';
                badge.innerHTML = '<i class="ti ti-check me-1"></i>' + text;
                break;
            case 'error':
                badge.className = 'badge bg-danger';
                badge.innerHTML = '<i class="ti ti-alert-triangle me-1"></i>' + text;
                break;
        }
    }

    // ==================
    // DATA MIGRATION
    // ==================

    function migrateOldFormatToNew(oldDays) {
        return oldDays.map(oldDay => {
            // If already has new structure, return as is
            if (oldDay.subconcepts !== undefined) {
                return oldDay;
            }

            // Migrate old format
            return {
                dayNumber: oldDay.dayNumber,
                dayTitle: oldDay.concept || `D√≠a ${oldDay.dayNumber}`,
                subconcepts: oldDay.concept ? [
                    {
                        time: "",
                        concept: oldDay.concept || "",
                        vehicleType: oldDay.vehicleType || "",
                        unitPrice: oldDay.unitPrice,
                        total: oldDay.total || 0,
                        notes: oldDay.notes || ""
                    }
                ] : [],
                dayTotal: oldDay.total || 0
            };
        });
    }

    // ==================
    // DATA LOADING
    // ==================

    async function loadServiceItems() {
        const loadStart = Date.now();
        console.log(`üì• [${loadStart}] === loadServiceItems called ===`);
        console.log('   üìã Context:', {
            quoteId,
            isNewQuote,
            currentServiceItemsData: serviceItemsData ? serviceItemsData.days?.length : 'none'
        });

        if (isNewQuote) {
            console.log('New quote - showing empty state');
            renderTable();
            updateTotalsDisplay();
            return;
        }

        try {
            const token = getAccessToken();
            console.log('Access token exists:', !!token);

            const url = `/api/quotes/${quoteId}`;
            console.log('Fetching from:', url);

            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                }
            });

            console.log('Response status:', response.status);
            const result = await response.json();
            console.log('Response data:', result);

            if (result.success && result.data) {
                let quote = result.data;
                console.log('Quote serviceItems:', quote.serviceItems);

                // Migrate old quote structure (quote-level rate) to new (subconcept-level rate)
                quote = migrateQuoteRateToSubconcepts(quote);

                // Store quote's number of people for validation
                quoteNumberOfPeople = quote.numberOfPeople || 1;
                console.log('Quote numberOfPeople:', quoteNumberOfPeople);

                if (quote.serviceItems) {
                    let days = quote.serviceItems.days || [];
                    console.log('Days loaded:', days.length);

                    // Detect old format and migrate
                    if (days.length > 0 && days[0].concept !== undefined && days[0].subconcepts === undefined) {
                        console.log('Migrating old format to new subconcepts structure...');
                        days = migrateOldFormatToNew(days);
                    }

                    // Migrate subconcepts to add type field
                    days = days.map(day => ({
                        ...day,
                        subconcepts: day.subconcepts.map(migrateSubconceptToTyped)
                    }));
                    console.log('Subconcepts migrated to typed format');

                    serviceItemsData = {
                        days: days,
                        subtotal: quote.serviceItems.subtotal || 0,
                        iva: quote.serviceItems.iva || 0,
                        total: quote.serviceItems.total || 0
                    };

                    console.log('serviceItemsData set:', serviceItemsData);
                    console.log('Calling renderTable()...');
                    renderTable();

                    // Recalculate totals from loaded data (in case of data inconsistencies)
                    recalculateAllDayTotals();
                    recalculateGeneralTotals();
                } else {
                    console.log('No serviceItems in quote data - showing empty state');
                    // Initialize with empty data and show empty state
                    serviceItemsData = {
                        days: [],
                        subtotal: 0,
                        iva: 0,
                        total: 0
                    };
                    renderTable();
                    updateTotalsDisplay();
                }
            } else {
                console.log('Response not successful or no data');
            }
        } catch (error) {
            console.error('Error loading service items:', error);
            showAlert('servicesAlerts', 'Error al cargar los servicios', 'danger');
        }
    }

    // ==================
    // RENDERING
    // ==================

    function renderTable() {
        const renderStart = Date.now();
        console.log(`üé® [${renderStart}] === renderTable called ===`);
        
        const tbody = document.getElementById('servicesTableBody');
        const emptyState = document.getElementById('emptyState');
        const tableContainer = document.getElementById('servicesTableContainer');

        console.log(`   üîç DOM elements check:`, { 
            tbody: !!tbody, 
            emptyState: !!emptyState, 
            tableContainer: !!tableContainer 
        });

        if (!tbody || !emptyState || !tableContainer) {
            console.error('   ‚ùå Missing required DOM elements!');
            return;
        }

        tbody.innerHTML = '';
        console.log(`   üßπ Cleared table body`);

        const daysCount = serviceItemsData.days.length;
        console.log(`   üìä Days to render: ${daysCount}`);

        if (daysCount === 0) {
            console.log('   üì≠ No days - showing empty state');
            emptyState.classList.remove('d-none');
            emptyState.classList.add('d-flex');
            tableContainer.classList.add('d-none');
            tableContainer.classList.remove('d-block');
        } else {
            console.log(`   üèóÔ∏è  Rendering ${daysCount} days`);
            emptyState.classList.remove('d-flex');
            emptyState.classList.add('d-none');
            tableContainer.classList.remove('d-none');
            tableContainer.classList.add('d-block');

            serviceItemsData.days.forEach((day, dayIndex) => {
                const dayRenderStart = Date.now();
                console.log(`   üìÖ [${dayRenderStart}] Rendering day ${dayIndex + 1}: ${day.subconcepts?.length || 0} subconcepts`);
                
                // Count experience subconcepts for debugging
                const experienceSubconcepts = day.subconcepts?.filter(sub => sub.type === 'experiencia') || [];
                if (experienceSubconcepts.length > 0) {
                    console.log(`      üé≠ Found ${experienceSubconcepts.length} experience subconcepts in day ${dayIndex + 1}`);
                    experienceSubconcepts.forEach((exp, i) => {
                        console.log(`         üéØ Experience ${i + 1}: ${exp.experienceId || 'no ID'} - "${exp.concept || 'no concept'}"`);
                    });
                }
                
                renderDay(dayIndex, true);
                
                const dayRenderTime = Date.now() - dayRenderStart;
                console.log(`      ‚úÖ Day ${dayIndex + 1} rendered in ${dayRenderTime}ms`);
            });
        }
        
        const totalRenderTime = Date.now() - renderStart;
        console.log(`üé® [+${totalRenderTime}ms] Table rendering completed`);
    }

    function renderDay(dayIndex, appendToEnd = false) {
        const day = serviceItemsData.days[dayIndex];
        if (!day) return;

        const tbody = document.getElementById('servicesTableBody');

        // Remove existing rows for this day
        const existingRows = document.querySelectorAll(`tr[data-day-index="${dayIndex}"]`);
        existingRows.forEach(row => row.remove());

        // Calculate rowspan: 1 (header) + subconcepts length
        const rowspan = 1 + (day.subconcepts?.length || 0);

        // Create header row
        const headerRow = createDayHeaderRow(day, dayIndex, rowspan);

        // Find insertion point
        let insertBeforeRow = null;
        if (!appendToEnd && dayIndex < serviceItemsData.days.length - 1) {
            insertBeforeRow = tbody.querySelector(`tr[data-day-index="${dayIndex + 1}"]`);
        }

        // Insert header
        if (insertBeforeRow) {
            tbody.insertBefore(headerRow, insertBeforeRow);
        } else {
            tbody.appendChild(headerRow);
        }

        // Insert subconcept rows
        day.subconcepts.forEach((subconcept, subIdx) => {
            const subRow = createSubconceptRow(day, dayIndex, subconcept, subIdx);

            if (insertBeforeRow) {
                tbody.insertBefore(subRow, insertBeforeRow);
            } else {
                tbody.appendChild(subRow);
            }
        });

        // Add separator after last subconcept
        if (dayIndex < serviceItemsData.days.length - 1) {
            const separator = document.createElement('tr');
            separator.className = 'day-separator';
            separator.dataset.dayIndex = dayIndex;
            separator.innerHTML = '<td colspan="7" class="p-0 border-0"></td>';

            if (insertBeforeRow) {
                tbody.insertBefore(separator, insertBeforeRow);
            } else {
                tbody.appendChild(separator);
            }
        }
    }

    function createDayHeaderRow(day, dayIndex, rowspan) {
        const tr = document.createElement('tr');
        tr.dataset.dayIndex = dayIndex;
        tr.dataset.rowType = 'day-header';

        tr.innerHTML = `
            <td class="text-center">
                <button class="btn btn-sm btn-danger delete-day-btn"
                        data-day-index="${dayIndex}"
                        title="Eliminar d√≠a completo">
                    <i class="ti ti-trash"></i>
                </button>
            </td>
            <td rowspan="${rowspan}" class="text-center align-middle">
                <div class="d-flex flex-column align-items-center gap-2">
                    <span class="badge bg-primary fs-6">D√≠a ${day.dayNumber}</span>
                    <input type="date"
                           class="form-control form-control-sm"
                           data-day-index="${dayIndex}"
                           data-field="dayDate"
                           title="Fecha del d√≠a (opcional)"
                           style="max-width: 150px;"
                           value="${day.dayDate || ''}">
                </div>
            </td>
            <td>
                <input type="text"
                       class="form-control form-control-sm mb-2 fw-bold"
                       data-day-index="${dayIndex}"
                       data-field="dayTitle"
                       placeholder="T√≠tulo del d√≠a (ej: D√≠a 1 - Llegada)"
                       value="${day.dayTitle || ''}">
                <div class="btn-group w-100" role="group" aria-label="Agregar subconcepto">
                    <button class="btn btn-sm btn-outline-primary add-subconcept-btn"
                            data-day-index="${dayIndex}"
                            data-type="regular"
                            title="Agregar concepto regular">
                        <i class="ti ti-plus"></i> Subconcepto
                    </button>
                    <button class="btn btn-sm btn-outline-primary add-subconcept-btn"
                            data-day-index="${dayIndex}"
                            data-type="traslado"
                            title="Agregar traslado">
                        <i class="ti ti-plus"></i> Traslado
                    </button>
                    <button class="btn btn-sm btn-outline-primary add-subconcept-btn"
                            data-day-index="${dayIndex}"
                            data-type="experiencia"
                            title="Agregar experiencia">
                        <i class="ti ti-plus"></i> Experiencia
                    </button>
                    <button class="btn btn-sm btn-outline-primary add-subconcept-btn"
                            data-day-index="${dayIndex}"
                            data-type="tour"
                            title="Agregar tour">
                        <i class="ti ti-plus"></i> Tour
                    </button>
                </div>
            </td>
            <td></td>
            <td></td>
            <td></td>
            <td rowspan="${rowspan}" class="text-center align-middle bg-light">
                <div class="day-total-container">
                    <small class="text-muted d-block mb-1">Total D√≠a ${day.dayNumber}</small>
                    <span class="day-total-display fw-bold fs-5" data-day-index="${dayIndex}">
                        ${currencyFormatter.format(day.dayTotal || 0)}
                    </span>
                    <small class="text-muted d-block mt-1">MXN</small>

                    <hr class="my-2">

                    <small class="text-muted d-block mb-1">Costo por Persona</small>
                    <small class="text-muted d-block" style="font-size: 0.7rem;">(${quoteNumberOfPeople} ${quoteNumberOfPeople === 1 ? 'persona' : 'personas'})</small>
                    <span class="day-per-person-display fw-bold fs-5" data-day-index="${dayIndex}">
                        ${currencyFormatter.format(quoteNumberOfPeople > 0 ? (day.dayTotal || 0) / quoteNumberOfPeople : 0)}
                    </span>
                    <small class="text-muted d-block mt-1">MXN</small>
                </div>
            </td>
            <td></td>
        `;

        // Attach listeners
        const titleInput = tr.querySelector('input[data-field="dayTitle"]');
        titleInput.addEventListener('input', (e) => {
            updateDayField(dayIndex, 'dayTitle', e.target.value);
        });

        const dateInput = tr.querySelector('input[data-field="dayDate"]');
        dateInput.addEventListener('change', (e) => {
            const newDate = e.target.value;
            const oldDate = serviceItemsData.days[dayIndex]?.dayDate;
            
            console.log(`üóìÔ∏è  Day ${dayIndex + 1} date changed: "${oldDate || 'none'}" ‚Üí "${newDate || 'none'}"`);
            
            updateDayField(dayIndex, 'dayDate', newDate);
            
            // Debounce the selector refresh to prevent rate limiting from rapid date changes
            if (dateChangeDebounce.timeouts.has(dayIndex)) {
                clearTimeout(dateChangeDebounce.timeouts.get(dayIndex));
            }
            
            const timeoutId = setTimeout(() => {
                console.log(`üïê Executing debounced refresh for day ${dayIndex + 1} after ${dateChangeDebounce.delay}ms delay`);
                // Refresh experience and tour selectors when date changes
                refreshExperienceSelectorsForDay(dayIndex);
                refreshTourSelectorsForDay(dayIndex);
                dateChangeDebounce.timeouts.delete(dayIndex);
            }, dateChangeDebounce.delay);
            
            dateChangeDebounce.timeouts.set(dayIndex, timeoutId);
            console.log(`‚è±Ô∏è Debouncing date change refresh for day ${dayIndex + 1} - will execute in ${dateChangeDebounce.delay}ms`);
        });

        // Attach listeners to all three "add subconcept" buttons
        const addSubBtns = tr.querySelectorAll('.add-subconcept-btn');
        addSubBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const type = btn.dataset.type;
                addSubconcept(dayIndex, type);
            });
        });

        // Attach delete day listener
        const deleteBtn = tr.querySelector('.delete-day-btn');
        deleteBtn.addEventListener('click', () => openDeleteDayModal(dayIndex));

        return tr;
    }

    function createSubconceptRow(day, dayIndex, subconcept, subconceptIndex) {
        const tr = document.createElement('tr');
        tr.dataset.dayIndex = dayIndex;
        tr.dataset.subconceptIndex = subconceptIndex;
        tr.dataset.rowType = 'subconcept';
        tr.dataset.type = subconcept.type || 'regular';

        const subType = subconcept.type || 'regular';

        // Debug: Log numberOfPeople values
        console.log(`Creating subconcept row - Type: ${subType}, numberOfPeople: ${subconcept.numberOfPeople}, quoteNumberOfPeople: ${quoteNumberOfPeople}`);

        // Build HTML based on subconcept type
        let conceptCellHTML = '';
        let vehicleCellHTML = '';

        // === CONCEPT CELL (varies by type) ===
        if (subType === 'traslado') {
            conceptCellHTML = `
                <td>
                    <!-- Time Input -->
                    <div class="d-flex align-items-center gap-2 mb-2">
                        <i class="ti ti-clock text-primary"></i>
                        <input type="text"
                               class="form-control form-control-sm time-input"
                               data-day-index="${dayIndex}"
                               data-subconcept-index="${subconceptIndex}"
                               data-field="time"
                               placeholder="HH:MM"
                               value="${subconcept.time || ''}"
                               maxlength="5"
                               style="max-width: 80px; flex-shrink: 0;">
                    </div>

                    <!-- STEP 1: Rate Selector (NEW) -->
                    <div class="mb-2">
                        <label class="form-label small fw-bold">1. Seleccionar Tarifa</label>
                        <select class="form-select form-select-sm rate-selector"
                                data-day-index="${dayIndex}"
                                data-subconcept-index="${subconceptIndex}"
                                id="rateSelector_${dayIndex}_${subconceptIndex}"
                                ${subconcept.rateId ? '' : 'required'}>
                            <option value="">Seleccionar tarifa...</option>
                        </select>
                    </div>

                    <!-- STEP 2: Transfer Selector (depends on rate) -->
                    <div class="mb-2">
                        <label class="form-label small fw-bold">2. Seleccionar Traslado</label>
                        <select class="form-select form-select-sm transfer-selector"
                                data-day-index="${dayIndex}"
                                data-subconcept-index="${subconceptIndex}"
                                id="transferSelector_${dayIndex}_${subconceptIndex}"
                                ${subconcept.rateId ? '' : 'disabled'}>
                            <option value="">Primero seleccione tarifa...</option>
                        </select>
                    </div>

                    ${subconcept.concept ? `<small class="text-muted mt-1 d-block">${subconcept.concept}</small>` : ''}
                </td>
            `;
        } else if (subType === 'tour') {
            conceptCellHTML = `
                <td>
                    <!-- Time Input -->
                    <div class="d-flex align-items-center gap-2 mb-2">
                        <i class="ti ti-clock text-primary"></i>
                        <input type="text"
                               class="form-control form-control-sm time-input"
                               data-day-index="${dayIndex}"
                               data-subconcept-index="${subconceptIndex}"
                               data-field="time"
                               placeholder="HH:MM"
                               value="${subconcept.time || ''}"
                               maxlength="5"
                               style="max-width: 80px; flex-shrink: 0;">
                    </div>

                    <!-- STEP 1: Rate Selector -->
                    <div class="mb-2">
                        <label class="form-label small fw-bold">1. Seleccionar Tarifa</label>
                        <select class="form-select form-select-sm tour-rate-selector"
                                data-day-index="${dayIndex}"
                                data-subconcept-index="${subconceptIndex}"
                                id="tourRateSelector_${dayIndex}_${subconceptIndex}"
                                ${subconcept.rateId ? '' : 'required'}>
                            <option value="">Seleccionar tarifa...</option>
                        </select>
                    </div>

                    <!-- STEP 2: Destination Selector (depends on rate) -->
                    <div class="mb-2">
                        <label class="form-label small fw-bold">2. Seleccionar Destino</label>
                        <select class="form-select form-select-sm tour-destination-selector"
                                data-day-index="${dayIndex}"
                                data-subconcept-index="${subconceptIndex}"
                                id="tourDestinationSelector_${dayIndex}_${subconceptIndex}"
                                ${subconcept.rateId ? '' : 'disabled'}>
                            <option value="">Primero seleccione tarifa...</option>
                        </select>
                    </div>
                </td>
            `;
        } else if (subType === 'experiencia') {
            conceptCellHTML = `
                <td>
                    <div class="d-flex align-items-center gap-2 mb-2">
                        <i class="ti ti-clock text-primary"></i>
                        <input type="text"
                               class="form-control form-control-sm time-input"
                               data-day-index="${dayIndex}"
                               data-subconcept-index="${subconceptIndex}"
                               data-field="time"
                               placeholder="HH:MM"
                               value="${subconcept.time || ''}"
                               maxlength="5"
                               style="max-width: 80px; flex-shrink: 0;">
                    </div>
                    <select class="form-select form-select-sm experience-selector"
                            data-day-index="${dayIndex}"
                            data-subconcept-index="${subconceptIndex}"
                            id="experienceSelector_${dayIndex}_${subconceptIndex}">
                        <option value="">Seleccionar experiencia...</option>
                    </select>
                    <div id="experiencePackageTable_${dayIndex}_${subconceptIndex}" class="mt-2" style="display: none;"></div>
                </td>
            `;
        } else {
            // Regular type
            conceptCellHTML = `
                <td>
                    <div class="d-flex align-items-center gap-2">
                        <i class="ti ti-clock text-primary"></i>
                        <input type="text"
                               class="form-control form-control-sm time-input"
                               data-day-index="${dayIndex}"
                               data-subconcept-index="${subconceptIndex}"
                               data-field="time"
                               placeholder="HH:MM"
                               value="${subconcept.time || ''}"
                               maxlength="5"
                               style="max-width: 80px; flex-shrink: 0;">
                        <input type="text"
                               class="form-control form-control-sm"
                               data-day-index="${dayIndex}"
                               data-subconcept-index="${subconceptIndex}"
                               data-field="concept"
                               placeholder="Ej: Comida grupal"
                               value="${subconcept.concept || ''}"
                               style="flex-grow: 1;">
                    </div>
                </td>
            `;
        }

        // === VEHICLE CELL (varies by type) ===
        if (subType === 'regular') {
            vehicleCellHTML = `
                <td>
                    <span class="badge bg-secondary">N/A</span>
                </td>
            `;
        } else if (subType === 'traslado') {
            const hasVehicle = subconcept.vehicleTypeId;
            // More robust capacity checking - use new fields if available, fallback to legacy field, show capacity info if we have a vehicle
            const hasCapacities = hasVehicle && (
                (subconcept.vehiclePassengerCapacity !== null && subconcept.vehiclePassengerCapacity !== undefined) ||
                (subconcept.vehicleCapacity !== null && subconcept.vehicleCapacity !== undefined)
            );

            // Determine the initial message for vehicle selector based on state
            let vehicleSelectorMessage = 'Primero seleccione un traslado';
            if (subconcept.transferId) {
                vehicleSelectorMessage = 'Seleccionar veh√≠culo...';
            }

            vehicleCellHTML = `
                <td>
                    <select class="form-select form-select-sm vehicle-type-selector"
                            data-day-index="${dayIndex}"
                            data-subconcept-index="${subconceptIndex}"
                            id="vehicleTypeSelector_${dayIndex}_${subconceptIndex}">
                        <option value="">${vehicleSelectorMessage}</option>
                    </select>

                    ${hasCapacities ? `
                        <div class="mt-2 small text-muted">
                            <div class="d-flex align-items-center gap-1">
                                <i class="ti ti-users"></i>
                                <span>Capacidad: ${subconcept.vehiclePassengerCapacity || subconcept.vehicleCapacity || 'N/D'} personas</span>
                            </div>
                            <div class="d-flex align-items-center gap-1">
                                <i class="ti ti-briefcase"></i>
                                <span>Maletas: ${subconcept.vehicleTrunkCapacity || 'N/D'}</span>
                            </div>
                        </div>
                    ` : ''}

                    ${hasVehicle ? `
                        <div class="form-check mt-2">
                            <input class="form-check-input additional-vehicle-checkbox"
                                   type="checkbox"
                                   data-day-index="${dayIndex}"
                                   data-subconcept-index="${subconceptIndex}"
                                   id="additionalVehicle_${dayIndex}_${subconceptIndex}"
                                   ${subconcept.additionalVehicleForLuggage ? 'checked' : ''}>
                            <label class="form-check-label small" for="additionalVehicle_${dayIndex}_${subconceptIndex}">
                                Veh√≠culo adicional para maletas
                            </label>
                        </div>
                    ` : ''}
                </td>
            `;
        } else if (subType === 'tour') {
            const hasVehicle = subconcept.vehicleTypeId;
            // More robust capacity checking - use new fields if available, fallback to legacy field, show capacity info if we have a vehicle
            const hasCapacities = hasVehicle && (
                (subconcept.vehiclePassengerCapacity !== null && subconcept.vehiclePassengerCapacity !== undefined) ||
                (subconcept.vehicleCapacity !== null && subconcept.vehicleCapacity !== undefined)
            );

            // Determine the initial message for vehicle selector based on state
            let vehicleSelectorMessage = 'Primero seleccione un destino';
            if (subconcept.destinationId) {
                vehicleSelectorMessage = 'Seleccionar veh√≠culo...';
            }

            vehicleCellHTML = `
                <td>
                    <select class="form-select form-select-sm tour-vehicle-selector"
                            data-day-index="${dayIndex}"
                            data-subconcept-index="${subconceptIndex}"
                            id="tourVehicleSelector_${dayIndex}_${subconceptIndex}">
                        <option value="">${vehicleSelectorMessage}</option>
                    </select>

                    ${hasCapacities ? `
                        <div class="mt-2 small text-muted">
                            <div class="d-flex align-items-center gap-1">
                                <i class="ti ti-users"></i>
                                <span>Capacidad: ${subconcept.vehiclePassengerCapacity || subconcept.vehicleCapacity || 'N/D'} personas</span>
                            </div>
                            <div class="d-flex align-items-center gap-1">
                                <i class="ti ti-briefcase"></i>
                                <span>Maletas: ${subconcept.vehicleTrunkCapacity || 'N/D'}</span>
                            </div>
                        </div>
                    ` : ''}

                    ${hasVehicle ? `
                        <div class="form-check mt-2">
                            <input class="form-check-input additional-vehicle-checkbox"
                                   type="checkbox"
                                   data-day-index="${dayIndex}"
                                   data-subconcept-index="${subconceptIndex}"
                                   id="additionalVehicle_${dayIndex}_${subconceptIndex}"
                                   ${subconcept.additionalVehicleForLuggage ? 'checked' : ''}>
                            <label class="form-check-label small" for="additionalVehicle_${dayIndex}_${subconceptIndex}">
                                Veh√≠culo adicional para maletas
                            </label>
                        </div>
                    ` : ''}
                </td>
            `;
        } else if (subType === 'experiencia') {
            // Experiencia: mostrar tipo de veh√≠culo asignado (solo lectura)
            vehicleCellHTML = `
                <td>
                    ${subconcept.vehicleType ? `
                        <div class="form-control form-control-sm bg-light" style="cursor: not-allowed;">
                            <i class="ti ti-car me-1 text-muted"></i>
                            <span>${subconcept.vehicleType}</span>
                        </div>
                    ` : `
                        <span class="badge bg-secondary">N/A</span>
                    `}
                </td>
            `;
        } else {
            // Regular: no aplica veh√≠culo
            vehicleCellHTML = `
                <td>
                    <span class="badge bg-secondary">N/A</span>
                </td>
            `;
        }

        tr.innerHTML = `
            <td class="text-center">
                <button class="btn btn-sm btn-danger delete-subconcept-btn"
                        data-day-index="${dayIndex}"
                        data-subconcept-index="${subconceptIndex}"
                        title="Eliminar subconcepto">
                    <i class="ti ti-trash"></i>
                </button>
            </td>
            ${conceptCellHTML}
            ${vehicleCellHTML}
            <td>
                ${subType === 'traslado' || subType === 'tour' ? `
                    <!-- Traslado/Tour: Price + Checkboxes + Number of People -->
                    <div class="d-flex flex-column gap-2">
                        <!-- Unit Price Input (top) - readonly for traslado/tour -->
                        <input type="text"
                               class="form-control form-control-sm text-end unit-price-input bg-light"
                               data-day-index="${dayIndex}"
                               data-subconcept-index="${subconceptIndex}"
                               data-field="unitPrice"
                               placeholder="$0.00"
                               value="${subconcept.unitPrice !== null && subconcept.unitPrice !== undefined ? formatCurrency(subconcept.isCashPayment ? subconcept.unitPrice : subconcept.unitPrice + (subconcept.surcharge || subconcept.unitPrice * 0.21)) : ''}"
                               readonly>

                        <!-- Cash Payment Checkbox for traslado/tour -->
                        <div class="form-check">
                            <input type="checkbox"
                                   class="form-check-input cash-payment-checkbox"
                                   data-day-index="${dayIndex}"
                                   data-subconcept-index="${subconceptIndex}"
                                   data-field="isCashPayment"
                                   id="cashPayment_${dayIndex}_${subconceptIndex}"
                                   ${subconcept.isCashPayment ? 'checked' : ''}>
                            <label class="form-check-label small" for="cashPayment_${dayIndex}_${subconceptIndex}">
                                Pago en Efectivo
                            </label>
                        </div>

                        <!-- Number of People Input (bottom) - readonly for traslados/tours (uses quote's numberOfPeople) -->
                        <input type="number"
                               class="form-control form-control-sm text-center bg-light"
                               data-day-index="${dayIndex}"
                               data-subconcept-index="${subconceptIndex}"
                               data-field="numberOfPeople"
                               placeholder="${quoteNumberOfPeople} pers."
                               min="1"
                               step="1"
                               value="${subconcept.numberOfPeople !== null && subconcept.numberOfPeople !== undefined ? subconcept.numberOfPeople : quoteNumberOfPeople}"
                               title="Cantidad de personas de la cotizaci√≥n"
                               readonly>
                    </div>
                ` : subType === 'experiencia' ? `
                    <!-- Experiencia: Price + Checkbox + Number of People -->
                    <div class="d-flex flex-column gap-2">
                        <!-- 1. Unit Price Input (top) - readonly for experiencia -->
                        <input type="text"
                               class="form-control form-control-sm text-end unit-price-input bg-light"
                               data-day-index="${dayIndex}"
                               data-subconcept-index="${subconceptIndex}"
                               data-field="unitPrice"
                               placeholder="$0.00"
                               value="${subconcept.unitPrice !== null && subconcept.unitPrice !== undefined ? formatCurrency(subconcept.isCashPayment ? subconcept.unitPrice : subconcept.unitPrice + (subconcept.surcharge || subconcept.unitPrice * 0.21)) : ''}"
                               readonly>

                        <!-- Cash Payment Checkbox for experiencia -->
                        <div class="form-check">
                            <input type="checkbox"
                                   class="form-check-input cash-payment-checkbox"
                                   data-day-index="${dayIndex}"
                                   data-subconcept-index="${subconceptIndex}"
                                   data-field="isCashPayment"
                                   id="cashPayment_${dayIndex}_${subconceptIndex}"
                                   ${subconcept.isCashPayment ? 'checked' : ''}>
                            <label class="form-check-label small" for="cashPayment_${dayIndex}_${subconceptIndex}">
                                Pago en Efectivo
                            </label>
                        </div>

                        <!-- 3. Number of People Input (bottom) -->
                        <input type="number"
                               class="form-control form-control-sm text-center"
                               data-day-index="${dayIndex}"
                               data-subconcept-index="${subconceptIndex}"
                               data-field="numberOfPeople"
                               placeholder="${quoteNumberOfPeople} pers."
                               min="1"
                               max="${quoteNumberOfPeople}"
                               step="1"
                               value="${subconcept.numberOfPeople !== null && subconcept.numberOfPeople !== undefined ? subconcept.numberOfPeople : quoteNumberOfPeople}"
                               title="M√°ximo: ${quoteNumberOfPeople} personas">
                    </div>
                ` : `
                    <!-- Regular/Service: Price + Number of People (NO Cash Payment Checkbox) -->
                    <div class="d-flex flex-column gap-2">
                        <!-- Unit Price Input (top) -->
                        <input type="text"
                               class="form-control form-control-sm text-end unit-price-input"
                               data-day-index="${dayIndex}"
                               data-subconcept-index="${subconceptIndex}"
                               data-field="unitPrice"
                               placeholder="$0.00"
                               value="${subconcept.unitPrice !== null && subconcept.unitPrice !== undefined ? formatCurrency(subconcept.unitPrice) : ''}">

                        <!-- Number of People Input (bottom) -->
                        <input type="number"
                               class="form-control form-control-sm text-center"
                               data-day-index="${dayIndex}"
                               data-subconcept-index="${subconceptIndex}"
                               data-field="numberOfPeople"
                               placeholder="${quoteNumberOfPeople} pers."
                               min="1"
                               max="${quoteNumberOfPeople}"
                               step="1"
                               value="${subconcept.numberOfPeople !== null && subconcept.numberOfPeople !== undefined ? subconcept.numberOfPeople : quoteNumberOfPeople}"
                               title="M√°ximo: ${quoteNumberOfPeople} personas">
                    </div>
                `}
            </td>
            <td>
                <input type="text"
                       class="form-control form-control-sm"
                       data-day-index="${dayIndex}"
                       data-subconcept-index="${subconceptIndex}"
                       data-field="notes"
                       placeholder="Notas adicionales"
                       value="${subconcept.notes || ''}">
            </td>
            <td class="text-center">
                <button class="btn btn-sm btn-danger delete-subconcept-btn"
                        data-day-index="${dayIndex}"
                        data-subconcept-index="${subconceptIndex}"
                        title="Eliminar subconcepto">
                    <i class="ti ti-trash"></i>
                </button>
            </td>
        `;

        // Attach input listeners
        const inputs = tr.querySelectorAll('input');
        inputs.forEach(input => {
            const field = input.dataset.field;

            if (field === 'unitPrice') {
                // Unit price input handling - only for editable fields (regular/service type)
                if (!input.hasAttribute('readonly')) {
                    input.addEventListener('input', (e) => {
                        // Format currency as user types
                        let value = e.target.value;
                        
                        // Remove any non-numeric characters except dots and commas
                        value = value.replace(/[^0-9.,]/g, '');
                        
                        // Convert to number for validation and storage
                        const numericValue = parseCurrency(value);
                        
                        // Update the subconcept field
                        updateSubconceptField(dayIndex, subconceptIndex, field, numericValue);
                    });
                    
                    input.addEventListener('blur', (e) => {
                        // Format the final value on blur
                        const numericValue = parseCurrency(e.target.value);
                        e.target.value = formatCurrency(numericValue);
                    });
                }
                // Skip event handlers for readonly unit price fields (traslado, tour, experiencia)
            } else if (field === 'numberOfPeople') {
                // Number of people input handling with validation
                input.addEventListener('input', (e) => {
                    let value = e.target.value ? parseInt(e.target.value) : 1;

                    // Validate: must be >= 1
                    if (value < 1) {
                        value = 1;
                        e.target.value = 1;
                    }

                    // Validate: cannot exceed quote's total numberOfPeople
                    if (value > quoteNumberOfPeople) {
                        value = quoteNumberOfPeople;
                        e.target.value = quoteNumberOfPeople;
                        showAlert('servicesAlerts',
                            `El n√∫mero de personas no puede exceder el total de la cotizaci√≥n (${quoteNumberOfPeople})`,
                            'warning');
                    }

                    updateSubconceptField(dayIndex, subconceptIndex, field, value);
                });
            } else {
                // Standard input handling for other fields
                input.addEventListener('input', (e) => {
                    let value = e.target.value;

                    updateSubconceptField(dayIndex, subconceptIndex, field, value);
                });

                // Special validation for time
                if (field === 'time') {
                    attachTimeInputValidation(input);
                }
            }
        });

        // Attach delete button listeners (both buttons: start and end of row)
        const deleteBtns = tr.querySelectorAll('.delete-subconcept-btn');
        deleteBtns.forEach(deleteBtn => {
            deleteBtn.addEventListener('click', () => {
                openDeleteSubconceptModal(dayIndex, subconceptIndex);
            });
        });

        // Attach additional vehicle checkbox listener (for traslados and tours)
        const additionalVehicleCheckbox = tr.querySelector('.additional-vehicle-checkbox');
        if (additionalVehicleCheckbox) {
            additionalVehicleCheckbox.addEventListener('change', (e) => {
                const isChecked = e.target.checked;
                const subconcept = serviceItemsData.days[dayIndex]?.subconcepts[subconceptIndex];
                if (subconcept) {
                    subconcept.additionalVehicleForLuggage = isChecked;
                    subconcept.total = calculateSubconceptTotal(subconcept);
                    recalculateDayTotal(dayIndex);
                    recalculateGeneralTotals();
                    markDirty();
                    triggerAutoSave();

                    console.log('Additional vehicle checkbox changed:', {
                        dayIndex,
                        subconceptIndex,
                        isChecked,
                        newTotal: subconcept.total
                    });
                }
            });
        }

        // Attach cash payment checkbox listener (only for types that have the checkbox)
        const cashPaymentCheckbox = tr.querySelector('.cash-payment-checkbox');
        if (cashPaymentCheckbox) {
            cashPaymentCheckbox.addEventListener('change', (e) => {
                const isChecked = e.target.checked;
                const subconcept = serviceItemsData.days[dayIndex]?.subconcepts[subconceptIndex];
                if (subconcept) {
                    subconcept.isCashPayment = isChecked;
                    
                    // Recalculate subconcept total with new pricing
                    subconcept.total = calculateSubconceptTotal(subconcept);
                    
                    // Recalculate day total
                    recalculateDayTotal(dayIndex);
                    
                    // Recalculate general totals
                    recalculateGeneralTotals();
                    
                    markDirty();
                    triggerAutoSave();

                    // Update unit price display immediately for better UX
                    updateUnitPriceDisplay(dayIndex, subconceptIndex, subconcept);

                    console.log('Cash payment checkbox changed:', {
                        dayIndex,
                        subconceptIndex,
                        isChecked,
                        conceptName: subconcept.concept
                    });

                    // Re-render the day to update pricing display
                    renderDay(dayIndex);
                }
            });
        }

        // Initialize rate selector first, then transfer selector for traslado type
        if (subType === 'traslado') {
            setTimeout(() => {
                initRateSelector(dayIndex, subconceptIndex, subconcept);
            }, 100);
        }

        // Initialize experience selector for experiencia type
        if (subType === 'experiencia') {
            console.log(`üöÄ Scheduling initExperienceSelector for day ${dayIndex + 1}, subconcept ${subconceptIndex} (100ms delay)`);
            setTimeout(() => {
                console.log(`‚ö° Executing scheduled initExperienceSelector for day ${dayIndex + 1}, subconcept ${subconceptIndex}`);
                initExperienceSelector(dayIndex, subconceptIndex, subconcept);
            }, 100);
        }

        // Initialize tour rate selector first, then tour selector for tour type
        if (subType === 'tour') {
            setTimeout(() => {
                initTourRateSelector(dayIndex, subconceptIndex, subconcept);
            }, 100);
        }

        return tr;
    }

    function attachTimeInputValidation(input) {
        // Auto-format: add ":" after 2 digits
        input.addEventListener('input', (e) => {
            let value = e.target.value;

            if (value.length === 2 && !value.includes(':')) {
                e.target.value = value + ':';
            }

            if (value.length > 5) {
                e.target.value = value.substring(0, 5);
            }
        });

        // Validate on blur
        input.addEventListener('blur', () => {
            if (input.value && !/^([0-1][0-9]|2[0-3]):[0-5][0-9]$/.test(input.value)) {
                input.classList.add('is-invalid');
                showAlert('servicesAlerts', 'Formato de hora inv√°lido. Use HH:MM (00:00 - 23:59)', 'warning');

                setTimeout(() => {
                    input.classList.remove('is-invalid');
                }, 3000);
            } else {
                input.classList.remove('is-invalid');
            }
        });
    }

    /**
     * Update unit price input field display
     * @param {number} dayIndex 
     * @param {number} subconceptIndex 
     * @param {object} subconcept 
     */
    function updateUnitPriceDisplay(dayIndex, subconceptIndex, subconcept) {
        const priceInput = document.querySelector(`input[data-day-index="${dayIndex}"][data-subconcept-index="${subconceptIndex}"][data-field="unitPrice"]`);
        if (priceInput && subconcept.unitPrice !== null && subconcept.unitPrice !== undefined) {
            // For types with cash payment checkbox (traslado, tour, experiencia), 
            // show card price when unchecked, cash price when checked
            if (subconcept.type !== 'regular' && subconcept.isCashPayment === false) {
                // Show card price (with surcharge)
                const cardPrice = subconcept.unitPrice + (subconcept.surcharge || subconcept.unitPrice * 0.21);
                priceInput.value = formatCurrency(cardPrice);
            } else {
                // Show cash price (base price)
                priceInput.value = formatCurrency(subconcept.unitPrice);
            }
        }
    }

    function updateTotalsDisplay() {
        const subtotalEl = document.getElementById('subtotalDisplay');
        const ivaEl = document.getElementById('ivaDisplay');
        const totalEl = document.getElementById('totalDisplay');
        const perPersonEl = document.getElementById('perPersonDisplay');
        const perPersonLabelEl = document.getElementById('perPersonLabelDisplay');

        if (subtotalEl) subtotalEl.textContent = currencyFormatter.format(serviceItemsData.subtotal);
        if (ivaEl) ivaEl.textContent = currencyFormatter.format(serviceItemsData.iva);
        if (totalEl) totalEl.textContent = currencyFormatter.format(serviceItemsData.total);

        // Calculate and display per person cost
        const perPersonCost = quoteNumberOfPeople > 0 ? serviceItemsData.total / quoteNumberOfPeople : 0;
        if (perPersonEl) perPersonEl.textContent = currencyFormatter.format(perPersonCost);
        if (perPersonLabelEl) {
            perPersonLabelEl.textContent = `(${quoteNumberOfPeople} ${quoteNumberOfPeople === 1 ? 'persona' : 'personas'})`;
        }
    }

    // ==================
    // TRANSFER/TRASLADO FUNCTIONS
    // ==================

    let availableServices = []; // Cache for available services
    
    // Caching system for tour data to prevent rate limiting
    const tourDataCache = {
        destinations: new Map(), // stores destination data indexed by "rateId_dayDate"
        vehicles: new Map(),     // stores vehicle data indexed by "rateId_destinationId_dayDate"
        cacheTimeout: 5 * 60 * 1000 // 5 minutes cache timeout
    };
    
    // Debouncing for date change handlers to prevent rate limiting
    const dateChangeDebounce = {
        timeouts: new Map(), // stores debounce timeouts indexed by dayIndex
        delay: 1000 // 1 second debounce delay
    };
    
    // Function to clear cache when needed (e.g., on page refresh or when data might be stale)
    function clearTourCache() {
        console.log('üßπ Clearing tour data cache');
        tourDataCache.destinations.clear();
        tourDataCache.vehicles.clear();
    }
    
    // Function to handle rate limit errors with exponential backoff
    async function fetchWithRetry(url, options, maxRetries = 3) {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetch(url, options);
                
                if (response.status === 429) {
                    const retryAfter = response.headers.get('Retry-After') || Math.pow(2, attempt);
                    console.warn(`üö´ Rate limit hit (attempt ${attempt}/${maxRetries}). Retrying after ${retryAfter}s...`);
                    
                    if (attempt < maxRetries) {
                        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
                        continue;
                    } else {
                        throw new Error(`Rate limit exceeded after ${maxRetries} attempts`);
                    }
                }
                
                return response;
            } catch (error) {
                // Don't retry if request was aborted (timeout)
                if (error.name === 'AbortError') {
                    console.error('üïê Request timed out');
                    throw new Error('Request timed out after 30 seconds');
                }
                
                if (attempt === maxRetries) throw error;
                
                const delay = Math.pow(2, attempt) * 1000;
                console.warn(`üîÑ Request failed (attempt ${attempt}/${maxRetries}). Retrying in ${delay}ms...`, error.message);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }

    async function loadAvailableServices() {
        if (availableServices.length > 0) {
            return availableServices; // Return cached services
        }

        try {
            const response = await fetch(`/api/quotes/${quoteId}/available-services`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${getAccessToken()}`,
                    'Content-Type': 'application/json'
                }
            });

            const result = await response.json();

            if (result.success && result.data) {
                availableServices = result.data;
                return availableServices;
            } else {
                console.error('Error loading services:', result.error);
                return [];
            }
        } catch (error) {
            console.error('Error loading available services:', error);
            showAlert('servicesAlerts', 'Error al cargar los traslados disponibles', 'danger');
            return [];
        }
    }

    /**
     * Initialize rate selector for traslado subconcept
     * Step 1 of 2-step process: Rate ‚Üí Transfer ‚Üí Vehicle
     */
    function initRateSelector(dayIndex, subconceptIndex, subconcept) {
        const selectElement = document.getElementById(`rateSelector_${dayIndex}_${subconceptIndex}`);
        if (!selectElement) {
            console.error('Rate selector not found');
            return;
        }

        // Load active rates
        loadActiveRatesForSelector().then(rates => {
            if (rates.length === 0) {
                selectElement.innerHTML = '<option value="">No hay tarifas disponibles</option>';
                return;
            }

            // Clear existing options
            selectElement.innerHTML = '<option value="">Seleccionar tarifa...</option>';

            // Add rate options
            rates.forEach(rate => {
                const option = document.createElement('option');
                option.value = rate.value;
                option.textContent = rate.label;

                // Pre-select if this subconcept has a rateId
                if (subconcept.rateId === rate.value) {
                    option.selected = true;
                }

                selectElement.appendChild(option);
            });

            // Attach change listener
            selectElement.onchange = function(e) {
                const rateId = e.target.value;
                const rateName = e.target.options[e.target.selectedIndex].text;

                if (rateId) {
                    // Update subconcept with selected rate
                    const subconcept = serviceItemsData.days[dayIndex]?.subconcepts[subconceptIndex];
                    if (subconcept) {
                        subconcept.rateId = rateId;
                        subconcept.rateName = rateName;

                        // IMPORTANTE: Limpiar selecci√≥n anterior de traslado y veh√≠culo
                        subconcept.transferId = null;
                        subconcept.vehicleTypeId = null;
                        subconcept.vehicleType = "";
                        subconcept.concept = "";
                        subconcept.unitPrice = 0;
                        subconcept.total = 0;

                        // Limpiar el selector de veh√≠culos inmediatamente
                        const vehicleSelector = document.getElementById(`vehicleTypeSelector_${dayIndex}_${subconceptIndex}`);
                        if (vehicleSelector) {
                            vehicleSelector.innerHTML = '<option value="">Primero seleccione un traslado</option>';
                        }

                        // Enable transfer selector
                        const transferSelector = document.getElementById(`transferSelector_${dayIndex}_${subconceptIndex}`);
                        if (transferSelector) {
                            transferSelector.disabled = false;
                            transferSelector.innerHTML = '<option value="">Cargando traslados...</option>';
                        }

                        // Initialize transfer selector with this rate
                        initTransferSelectorByRate(dayIndex, subconceptIndex, subconcept, rateId);

                        // Actualizar la fila visualmente
                        renderDay(dayIndex);

                        markDirty();
                        triggerAutoSave();
                    }
                } else {
                    // Si se deselecciona la tarifa, resetear todo
                    const subconcept = serviceItemsData.days[dayIndex]?.subconcepts[subconceptIndex];
                    if (subconcept) {
                        subconcept.rateId = null;
                        subconcept.rateName = "";
                        subconcept.transferId = null;
                        subconcept.vehicleTypeId = null;
                        subconcept.vehicleType = "";
                        subconcept.concept = "";
                        subconcept.unitPrice = 0;
                        subconcept.total = 0;

                        // Deshabilitar y limpiar transfer selector
                        const transferSelector = document.getElementById(`transferSelector_${dayIndex}_${subconceptIndex}`);
                        if (transferSelector) {
                            transferSelector.disabled = true;
                            transferSelector.innerHTML = '<option value="">Primero seleccione tarifa...</option>';
                        }

                        // Limpiar vehicle selector
                        const vehicleSelector = document.getElementById(`vehicleTypeSelector_${dayIndex}_${subconceptIndex}`);
                        if (vehicleSelector) {
                            vehicleSelector.innerHTML = '<option value="">Primero seleccione un traslado</option>';
                        }

                        renderDay(dayIndex);
                        markDirty();
                        triggerAutoSave();
                    }
                }
            };

            // If rate already selected, enable transfer selector
            if (subconcept.rateId) {
                const transferSelector = document.getElementById(`transferSelector_${dayIndex}_${subconceptIndex}`);
                if (transferSelector) {
                    transferSelector.disabled = false;
                }
                initTransferSelectorByRate(dayIndex, subconceptIndex, subconcept, subconcept.rateId);
            }
        });
    }

    /**
     * Load active rates for rate selector dropdown
     */
    async function loadActiveRatesForSelector() {
        try {
            const response = await fetch('/api/rates/active', {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${getAccessToken()}`,
                    'Content-Type': 'application/json'
                }
            });

            const result = await response.json();

            if (result.success && result.data) {
                return result.data; // [{value, label}]
            } else {
                console.error('Error loading rates:', result.error);
                return [];
            }
        } catch (error) {
            console.error('Error loading rates for selector:', error);
            showAlert('servicesAlerts', 'Error al cargar las tarifas', 'danger');
            return [];
        }
    }

    /**
     * Initialize transfer selector by rate (uses rateId instead of quoteId)
     * Step 2 of 2-step process: Rate ‚Üí Transfer ‚Üí Vehicle
     */
    function initTransferSelectorByRate(dayIndex, subconceptIndex, subconcept, rateId) {
        const selectElement = document.getElementById(`transferSelector_${dayIndex}_${subconceptIndex}`);
        if (!selectElement) {
            console.error('Transfer selector not found');
            return;
        }

        // Load services filtered by selected rate (NEW ENDPOINT)
        loadAvailableServicesByRate(rateId).then(routes => {
            if (routes.length === 0) {
                selectElement.innerHTML = '<option value="">No hay traslados para esta tarifa</option>';
                return;
            }

            // Clear existing options
            selectElement.innerHTML = '<option value="">Seleccionar traslado...</option>';

            // Add route options
            routes.forEach(route => {
                const option = document.createElement('option');
                option.value = route.routeKey;
                option.textContent = route.label;

                // Store route data
                option.dataset.routeData = JSON.stringify(route);

                // Pre-select if matches transferId
                if (subconcept.transferId) {
                    const hasMatchingVehicle = route.vehicles.some(v => v.serviceId === subconcept.transferId);
                    if (hasMatchingVehicle) {
                        option.selected = true;
                    }
                }

                selectElement.appendChild(option);
            });

            // Initialize Tom Select
            const tomSelectInstance = new TomSelect(selectElement, {
                placeholder: 'Buscar traslado (origen, destino)...',
                maxOptions: 1000,
                searchField: ['text'],
                sortField: 'text',
                closeAfterSelect: true,
                onChange: function(routeKey) {
                    if (!routeKey) return;

                    const option = selectElement.querySelector(`option[value="${routeKey}"]`);
                    if (!option) return;

                    const routeData = JSON.parse(option.dataset.routeData);
                    updateVehicleTypeSelector(dayIndex, subconceptIndex, routeData, subconcept);
                }
            });

            // If already has route selected, populate vehicle selector
            if (selectElement.value) {
                const option = selectElement.querySelector(`option[value="${selectElement.value}"]`);
                if (option) {
                    const routeData = JSON.parse(option.dataset.routeData);
                    updateVehicleTypeSelector(dayIndex, subconceptIndex, routeData, subconcept);
                }
            }

            console.log('Transfer selector initialized by rate', {
                dayIndex,
                subconceptIndex,
                rateId,
                routesCount: routes.length
            });
        });
    }

    /**
     * Load available services filtered by specific rate (NEW)
     */
    async function loadAvailableServicesByRate(rateId) {
        try {
            const response = await fetch(`/api/quotes/services-by-rate/${rateId}?numberOfPeople=${quoteNumberOfPeople}`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${getAccessToken()}`,
                    'Content-Type': 'application/json'
                }
            });

            const result = await response.json();
            console.log('API Response for services-by-rate:', {
                rateId,
                success: result.success,
                dataLength: result.data ? result.data.length : 'no data',
                fullResponse: result
            });

            if (result.success && result.data) {

                // Check if any routes have vehicles
                const hasVehicles = result.data.some(route => route.vehicles && route.vehicles.length > 0);
                if (!hasVehicles && quoteNumberOfPeople > 0) {
                    showAlert('servicesAlerts',
                        `No hay veh√≠culos disponibles con capacidad para ${quoteNumberOfPeople} personas. Por favor seleccione otra tarifa o reduzca el n√∫mero de personas.`,
                        'warning');
                }

                return result.data;
            } else {
                console.error('Error loading services by rate:', result.error);
                return [];
            }
        } catch (error) {
            console.error('Error loading available services by rate:', error);
            showAlert('servicesAlerts', 'Error al cargar los traslados para esta tarifa', 'danger');
            return [];
        }
    }

    // OLD FUNCTION - Kept for backward compatibility with existing quotes
    function initTransferSelector(dayIndex, subconceptIndex, subconcept) {
        const selectElement = document.getElementById(`transferSelector_${dayIndex}_${subconceptIndex}`);
        if (!selectElement) {
            console.error('Transfer selector not found');
            return;
        }

        // Load services (now grouped by route)
        loadAvailableServices().then(routes => {
            if (routes.length === 0) {
                selectElement.innerHTML = '<option value="">No hay traslados disponibles</option>';
                return;
            }

            // Clear existing options
            selectElement.innerHTML = '<option value="">Seleccionar traslado...</option>';

            // Add route options (simplified - only origin ‚Üí destination)
            routes.forEach(route => {
                const option = document.createElement('option');
                option.value = route.routeKey;
                option.textContent = route.label; // Just "Origin ‚Üí Destination"

                // Store route data including available vehicles
                option.dataset.routeData = JSON.stringify(route);

                // Pre-select if this subconcept matches this route
                // (check if any vehicle in this route matches the transferId)
                if (subconcept.transferId) {
                    const hasMatchingVehicle = route.vehicles.some(v => v.serviceId === subconcept.transferId);
                    if (hasMatchingVehicle) {
                        option.selected = true;
                    }
                }

                selectElement.appendChild(option);
            });

            // Initialize Tom Select
            const tomSelectInstance = new TomSelect(selectElement, {
                placeholder: 'Buscar traslado (origen, destino)...',
                maxOptions: 1000,
                searchField: ['text'],
                sortField: 'text',
                closeAfterSelect: true,
                onChange: function(routeKey) {
                    if (!routeKey) return;

                    // Get selected route data
                    const option = selectElement.querySelector(`option[value="${routeKey}"]`);
                    if (!option) return;

                    const routeData = JSON.parse(option.dataset.routeData);

                    // Update vehicle type selector with available vehicles for this route
                    updateVehicleTypeSelector(dayIndex, subconceptIndex, routeData, subconcept);
                }
            });

            // If already has a route selected, populate vehicle selector
            if (selectElement.value) {
                const option = selectElement.querySelector(`option[value="${selectElement.value}"]`);
                if (option) {
                    const routeData = JSON.parse(option.dataset.routeData);
                    updateVehicleTypeSelector(dayIndex, subconceptIndex, routeData, subconcept);
                }
            }

            console.log('Tom Select initialized for transfer selector', {
                dayIndex,
                subconceptIndex,
                routesCount: routes.length
            });
        });
    }

    function updateVehicleTypeSelector(dayIndex, subconceptIndex, routeData, subconcept) {
        const vehicleSelector = document.getElementById(`vehicleTypeSelector_${dayIndex}_${subconceptIndex}`);
        if (!vehicleSelector) {
            console.error('Vehicle type selector not found');
            return;
        }

        // Clear existing options
        vehicleSelector.innerHTML = '<option value="">Seleccionar veh√≠culo...</option>';

        console.log('updateVehicleTypeSelector called with:', {
            dayIndex,
            subconceptIndex,
            routeData: routeData,
            vehiclesCount: routeData.vehicles ? routeData.vehicles.length : 'undefined/null'
        });

        // Check if vehicles exist
        if (!routeData.vehicles || !Array.isArray(routeData.vehicles)) {
            console.warn('No vehicles available for route:', routeData);
            vehicleSelector.innerHTML = '<option value="">No hay veh√≠culos disponibles</option>';
            return;
        }

        // Sort vehicles by price (lowest to highest)
        const sortedVehicles = [...routeData.vehicles].sort((a, b) => a.price - b.price);

        // Add vehicle options from this route
        let preselectedVehicle = null;
        sortedVehicles.forEach(vehicle => {
            const option = document.createElement('option');
            option.value = vehicle.serviceId;
            option.textContent = vehicle.vehicleType;

            // Store vehicle data
            option.dataset.vehicleData = JSON.stringify(vehicle);

            // Pre-select if this matches the current transferId
            if (subconcept.transferId === vehicle.serviceId) {
                option.selected = true;
                preselectedVehicle = vehicle; // Store for capacity restoration
            }

            vehicleSelector.appendChild(option);
        });

        // If vehicle was pre-selected, restore its capacity
        if (preselectedVehicle) {
            // Restore capacity if not already set
            if (!subconcept.vehicleCapacity) {
                subconcept.vehicleCapacity = preselectedVehicle.capacity || null;
                console.log('Restored vehicleCapacity for pre-selected vehicle:', {
                    vehicleType: preselectedVehicle.vehicleType,
                    capacity: preselectedVehicle.capacity
                });
            }
        }
        // Auto-select first vehicle if none selected (cheapest one after sorting)
        else if (!subconcept.transferId && sortedVehicles.length > 0) {
            vehicleSelector.value = sortedVehicles[0].serviceId;
            // Trigger change to populate data
            const firstVehicle = sortedVehicles[0];
            populateTransferData(dayIndex, subconceptIndex, {
                ...routeData,
                ...firstVehicle
            });
        }

        // Attach change listener to vehicle selector
        vehicleSelector.onchange = function(e) {
            const serviceId = e.target.value;
            if (!serviceId) return;

            const option = vehicleSelector.querySelector(`option[value="${serviceId}"]`);
            if (!option) return;

            const vehicleData = JSON.parse(option.dataset.vehicleData);

            // Update transfer data with new vehicle selection
            populateTransferData(dayIndex, subconceptIndex, {
                ...routeData,
                ...vehicleData
            });
        };
    }

    function populateTransferData(dayIndex, subconceptIndex, transferData) {
        const subconcept = serviceItemsData.days[dayIndex]?.subconcepts[subconceptIndex];
        if (!subconcept) return;

        // Ensure numberOfPeople is set BEFORE calculating total
        if (!subconcept.numberOfPeople || subconcept.numberOfPeople === 1) {
            subconcept.numberOfPeople = quoteNumberOfPeople;
        }

        // Update subconcept data
        subconcept.transferId = transferData.serviceId;
        subconcept.concept = transferData.label;
        subconcept.vehicleTypeId = transferData.vehicleTypeId;
        subconcept.vehicleType = transferData.vehicleType;
        subconcept.vehicleCapacity = transferData.capacity || null; // Store capacity for per-person calculations
        subconcept.vehiclePassengerCapacity = transferData.capacity || null; // NEW - Passenger capacity for display
        subconcept.vehicleTrunkCapacity = transferData.trunkCapacity || null; // NEW - Trunk capacity for display
        subconcept.unitPrice = transferData.basePrice;
        subconcept.basePrice = transferData.basePrice;
        subconcept.surcharge = transferData.surcharge;
        subconcept.surchargePercentage = transferData.surchargePercentage;
        subconcept.notes = transferData.note || '';

        // NOW calculate total with correct numberOfPeople and vehicleCapacity
        subconcept.total = calculateSubconceptTotal(subconcept);

        // Update the UI fields without full re-render
        const priceInput = document.querySelector(`input[data-day-index="${dayIndex}"][data-subconcept-index="${subconceptIndex}"][data-field="unitPrice"]`);
        const notesInput = document.querySelector(`input[data-day-index="${dayIndex}"][data-subconcept-index="${subconceptIndex}"][data-field="notes"]`);
        const peopleInput = document.querySelector(`input[data-day-index="${dayIndex}"][data-subconcept-index="${subconceptIndex}"][data-field="numberOfPeople"]`);

        if (priceInput) {
            // For readonly fields (traslado, tour, experiencia), just show the unitPrice
            // For editable fields (regular/service), also just show the unitPrice (no cash payment logic here)
            priceInput.value = formatCurrency(subconcept.unitPrice);
        }
        if (notesInput) notesInput.value = subconcept.notes;
        if (peopleInput) peopleInput.value = subconcept.numberOfPeople;

        // Update vehicle multiplier badge
        const badge = document.querySelector(
            `.vehicle-multiplier[data-day-index="${dayIndex}"][data-subconcept-index="${subconceptIndex}"]`
        );
        if (badge) {
            badge.textContent = `${subconcept.vehicleMultiplier || 1}x`;
            const hasVehicle = subconcept.vehicleCapacity || subconcept.vehicleTypeId;
            badge.style.display = hasVehicle ? 'inline-block' : 'none';
        }

        // Recalculate totals
        recalculateDayTotal(dayIndex);
        recalculateGeneralTotals();

        // Update unit price display immediately
        updateUnitPriceDisplay(dayIndex, subconceptIndex, subconcept);
        
        markDirty();
        triggerAutoSave();

        console.log('Transfer data populated:', subconcept);
    }

    // ==================
    // EXPERIENCE FUNCTIONS
    // ==================

    let availableExperiences = []; // Cache for available experiences

    // Helper function to get day of week code from date string (0=Sunday, 1=Monday, etc.)
    function getDayOfWeekCode(dateString) {
        if (!dateString) return null;
        
        // Parse date string manually to avoid timezone issues
        // Expected format: YYYY-MM-DD
        const parts = dateString.split('-');
        if (parts.length !== 3) return null;
        
        const year = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10) - 1; // Month is 0-based in JS
        const day = parseInt(parts[2], 10);
        
        const date = new Date(year, month, day);
        return date.getDay(); // Returns 0-6 where 0=Sunday
    }

    // Helper function to check if experience is available on a specific day
    function isExperienceAvailableOnDay(experience, dayCode) {
        if (!experience.availability || !Array.isArray(experience.availability)) {
            // If no availability set, assume available anytime
            return true;
        }
        
        // Check if any availability schedule matches the target day
        const isAvailable = experience.availability.some(schedule => schedule.day === dayCode);
        
        // Debug log for experiences that don't match (to see what's being filtered out)
        if (!isAvailable) {
            const availableDays = experience.availability.map(s => s.day).join(',');
            console.log(`     ‚ùå "${experience.name}" not available on day ${dayCode}, available on: [${availableDays}]`);
        }
        
        return isAvailable;
    }

    async function loadAvailableExperiences(targetDate = null) {
        const startTime = Date.now();
        console.log(`   üì° [${startTime}] Starting API call to load experiences${targetDate ? ` for date ${targetDate}` : ''}`);
        
        try {
            const fetchStartTime = Date.now();
            const response = await fetch('/api/experiences?type=Experience&length=1000', {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${getAccessToken()}`,
                    'Content-Type': 'application/json'
                }
            });
            
            const fetchTime = Date.now() - fetchStartTime;
            console.log(`   üåê [+${fetchTime}ms] API fetch completed, status: ${response.status}`);

            const parseStartTime = Date.now();
            const result = await response.json();
            const parseTime = Date.now() - parseStartTime;
            console.log(`   üìù [+${parseTime}ms] JSON parse completed`);

            if (result.data && Array.isArray(result.data)) {
                const filterStartTime = Date.now();
                
                // Filter only active experiences
                let experiences = result.data.filter(exp => exp.active === true);
                console.log(`   üìä Found ${experiences.length} active experiences from ${result.data.length} total`);
                
                // If target date is provided, filter by day availability
                if (targetDate) {
                    const dayCode = getDayOfWeekCode(targetDate);
                    console.log(`   üìÖ Target date: ${targetDate} = day code ${dayCode} (${['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'][dayCode]})`);
                    if (dayCode !== null) {
                        const beforeCount = experiences.length;
                        experiences = experiences.filter(exp => isExperienceAvailableOnDay(exp, dayCode));
                        console.log(`   ‚úÖ Filtered from ${beforeCount} to ${experiences.length} experiences available on day ${dayCode}`);
                        
                        // Log sample of filtered experiences for debugging
                        if (experiences.length > 0 && experiences.length <= 3) {
                            experiences.forEach(exp => {
                                console.log(`     üéØ Available: "${exp.name}" (${exp.id})`);
                            });
                        } else if (experiences.length > 3) {
                            console.log(`     üéØ Available experiences: "${experiences[0].name}", "${experiences[1].name}", "${experiences[2].name}" and ${experiences.length - 3} more...`);
                        }
                    }
                }
                
                const filterTime = Date.now() - filterStartTime;
                const totalTime = Date.now() - startTime;
                console.log(`   ‚úÖ [+${filterTime}ms filter, +${totalTime}ms total] Returning ${experiences.length} experiences`);
                
                return experiences;
            } else {
                console.error('   ‚ùå Error loading experiences:', result.error || 'Invalid data structure');
                console.log(`   üìä Response structure:`, { hasData: !!result.data, isArray: Array.isArray(result.data), keys: Object.keys(result) });
                return [];
            }
        } catch (error) {
            const errorTime = Date.now() - startTime;
            console.error(`   ‚ùå [+${errorTime}ms] Error loading available experiences:`, error);
            showAlert('servicesAlerts', 'Error al cargar las experiencias disponibles', 'danger');
            return [];
        }
    }

    // Function to refresh all experience selectors for a specific day
    async function refreshExperienceSelectorsForDay(dayIndex) {
        const dayData = serviceItemsData.days[dayIndex];
        if (!dayData) return;

        const dayDate = dayData.dayDate;
        console.log(`üîÑ Refreshing experience selectors for day ${dayIndex + 1}, date: ${dayDate || 'none'}`);

        // Find all experience selectors for this day
        const experienceSelectors = document.querySelectorAll(`select[id^="experienceSelector_${dayIndex}_"]`);
        
        if (experienceSelectors.length === 0) {
            console.log(`   ‚ÑπÔ∏è  No experience selectors found for day ${dayIndex + 1}`);
            return;
        }

        try {
            // Load experiences for the new date
            console.log(`   üîç Executing experience query for ${dayDate ? `day-of-week filtering (${dayDate})` : 'all experiences'}`);
            const experiences = await loadAvailableExperiences(dayDate);

            // Update each experience selector
            experienceSelectors.forEach((selectElement, subIndex) => {
                const subconceptIndex = selectElement.id.split('_')[2];
                const subconcept = dayData.subconcepts[parseInt(subconceptIndex)];
                
                if (!subconcept || subconcept.type !== 'experiencia') return;

                // Store current selection
                const currentValue = selectElement.value;
                console.log(`   üîß Updating selector ${selectElement.id}, current selection: "${currentValue}"`);

                if (experiences.length === 0) {
                    selectElement.innerHTML = '<option value="">No hay experiencias disponibles para esta fecha</option>';
                    console.log(`   üìù Set "no experiences" message`);
                    
                    // Clear concept since no experiences are available
                    if (subconcept) {
                        subconcept.concept = '';
                    }
                } else {
                    // Clear and rebuild options
                    selectElement.innerHTML = '<option value="">Seleccionar experiencia...</option>';

                    let experienceStillAvailable = false;
                    experiences.forEach(experience => {
                        const option = document.createElement('option');
                        option.value = experience.id;
                        option.textContent = experience.name;
                        
                        // Restore selection if the experience is still available
                        if (currentValue === experience.id) {
                            option.selected = true;
                            experienceStillAvailable = true;
                        }
                        
                        selectElement.appendChild(option);
                    });
                    
                    // If the previously selected experience is no longer available, clear the concept
                    if (!experienceStillAvailable && currentValue) {
                        console.log(`   üßπ Clearing concept - selected experience "${currentValue}" no longer available for this date`);
                        if (subconcept) {
                            subconcept.experienceId = null;
                            subconcept.experienceName = '';
                            subconcept.concept = '';
                            subconcept.unitPrice = 0;
                            subconcept.total = 0;
                        }
                    }
                    
                    console.log(`   üìù Added ${experiences.length} experiences + 1 default option = ${selectElement.options.length} total options`);
                }

                // Refresh Tom Select if it exists
                if (selectElement.tomselect) {
                    // Store current selection before updating
                    const currentSelection = selectElement.tomselect.getValue();
                    
                    // Clear Tom Select options and reload from DOM
                    selectElement.tomselect.clearOptions();
                    selectElement.tomselect.sync();
                    
                    // Restore selection if the option still exists
                    if (currentSelection && selectElement.querySelector(`option[value="${currentSelection}"]`)) {
                        selectElement.tomselect.setValue(currentSelection, true);
                        console.log(`   üîÑ Tom Select updated and selection "${currentSelection}" restored`);
                    } else {
                        console.log(`   üîÑ Tom Select updated, previous selection cleared (no longer available)`);
                    }
                    
                    console.log(`   üìä Tom Select now has ${Object.keys(selectElement.tomselect.options).length} options`);
                } else {
                    console.log(`   ‚ÑπÔ∏è  No Tom Select instance found for ${selectElement.id}`);
                }
            });
            
            // Re-render the day to update the concept display and recalculate totals
            console.log(`   üîÑ Re-rendering day ${dayIndex + 1} to update displays`);
            recalculateDayTotal(dayIndex);
            recalculateGeneralTotals();
            renderDay(dayIndex);
        } catch (error) {
            console.error('Error refreshing experience selectors:', error);
        }
    }

    // Function to refresh all tour selectors for a specific day
    async function refreshTourSelectorsForDay(dayIndex) {
        const dayData = serviceItemsData.days[dayIndex];
        if (!dayData) return;

        const dayDate = dayData.dayDate;
        console.log(`üîÑ Refreshing tour selectors for day ${dayIndex + 1}, date: ${dayDate || 'none'}`);

        // Find all tour destination selectors for this day (they depend on date availability)
        const tourDestinationSelectors = document.querySelectorAll(`select[id^="tourDestinationSelector_${dayIndex}_"]`);
        
        if (tourDestinationSelectors.length === 0) {
            console.log(`   ‚ÑπÔ∏è  No tour destination selectors found for day ${dayIndex + 1}`);
            return;
        }

        try {
            // Collect all unique rate IDs to minimize API calls
            const uniqueRatesMap = new Map();
            const selectorsToRefresh = [];
            
            for (const selectElement of tourDestinationSelectors) {
                const subconceptIndex = selectElement.id.split('_')[2];
                const subconcept = dayData.subconcepts[parseInt(subconceptIndex)];
                
                if (!subconcept || subconcept.type !== 'tour' || !subconcept.rateId) {
                    console.log(`   ‚è≠Ô∏è  Skipping selector ${selectElement.id} - no rate selected`);
                    continue;
                }

                // Track unique rates for batch loading
                if (!uniqueRatesMap.has(subconcept.rateId)) {
                    uniqueRatesMap.set(subconcept.rateId, []);
                }
                uniqueRatesMap.get(subconcept.rateId).push({
                    selectElement,
                    subconceptIndex: parseInt(subconceptIndex),
                    subconcept
                });
                
                selectorsToRefresh.push({
                    selectElement,
                    subconceptIndex: parseInt(subconceptIndex),
                    subconcept
                });
            }
            
            if (selectorsToRefresh.length === 0) {
                console.log(`   ‚ÑπÔ∏è  No tour selectors need refreshing for day ${dayIndex + 1}`);
                return;
            }
            
            console.log(`   üìä Found ${selectorsToRefresh.length} tour selectors across ${uniqueRatesMap.size} unique rates`);
            
            // Pre-load destinations for all unique rates to utilize caching
            const rateIds = Array.from(uniqueRatesMap.keys());
            console.log(`   üöÄ Pre-loading destinations for rates: ${rateIds.join(', ')}`);
            
            await Promise.all(rateIds.map(rateId => 
                loadTourDestinationsByRate(rateId, dayDate)
            ));
            
            // Now refresh each selector (most calls will hit cache)
            for (const { selectElement, subconceptIndex, subconcept } of selectorsToRefresh) {
                console.log(`   üîß Refreshing tour destinations for selector ${selectElement.id}, rate: ${subconcept.rateId}`);
                
                // Re-initialize the destination selector with date filtering (will use cache)
                await initTourDestinationSelector(dayIndex, subconceptIndex, subconcept, subconcept.rateId);
                
                console.log(`   ‚úÖ Refreshed tour selector ${selectElement.id}`);
            }
            
            console.log(`   üîÑ Re-rendering day ${dayIndex + 1} after tour selector refresh`);
            recalculateDayTotal(dayIndex);
            recalculateGeneralTotals();
            renderDay(dayIndex);
        } catch (error) {
            console.error('Error refreshing tour selectors:', error);
        }
    }

    // ============================================================
    // TOUR SELECTOR FUNCTIONS (Rate ‚Üí Destination ‚Üí Vehicle)
    // ============================================================

    /**
     * Initialize tour rate selector with TomSelect and load rates
     * Step 1 of 3: Rate selection
     */
    function initTourRateSelector(dayIndex, subconceptIndex, subconcept) {
        const selectElement = document.getElementById(`tourRateSelector_${dayIndex}_${subconceptIndex}`);
        if (!selectElement) {
            console.error('Tour rate selector not found');
            return;
        }

        // Load active rates (exactly like traslados)
        loadActiveRatesForSelector().then(rates => {
            if (rates.length === 0) {
                selectElement.innerHTML = '<option value="">No hay tarifas disponibles</option>';
                return;
            }

            // Clear existing options
            selectElement.innerHTML = '<option value="">Seleccionar tarifa...</option>';

            // Add rate options (using .value and .label like traslados)
            rates.forEach(rate => {
                const option = document.createElement('option');
                option.value = rate.value;  // Use .value like traslados
                option.textContent = rate.label;  // Use .label like traslados

                // Pre-select if this subconcept has a rateId
                if (subconcept.rateId === rate.value) {
                    option.selected = true;
                }

                selectElement.appendChild(option);
            });

            // Attach change listener (NO TomSelect, just plain onchange like traslados)
            selectElement.onchange = function(e) {
                const rateId = e.target.value;
                const rateName = e.target.options[e.target.selectedIndex].text;

                if (rateId) {
                    // Update subconcept with selected rate
                    const subconcept = serviceItemsData.days[dayIndex]?.subconcepts[subconceptIndex];
                    if (subconcept) {
                        subconcept.rateId = rateId;
                        subconcept.rateName = rateName;

                        // IMPORTANTE: Limpiar selecciones anteriores
                        subconcept.destinationId = null;
                        subconcept.destinationPOI = "";
                        subconcept.tourId = null;
                        subconcept.vehicleTypeId = null;
                        subconcept.vehicleType = "";
                        subconcept.durationMinutes = 0;
                        subconcept.unitPrice = 0;
                        subconcept.total = 0;

                        // Limpiar destination selector
                        const destinationSelector = document.getElementById(`tourDestinationSelector_${dayIndex}_${subconceptIndex}`);
                        if (destinationSelector) {
                            if (destinationSelector.tomselect) {
                                destinationSelector.tomselect.destroy();
                            }
                            destinationSelector.innerHTML = '<option value="">Seleccionar destino...</option>';
                            destinationSelector.disabled = false;
                        }

                        // Limpiar vehicle selector
                        const vehicleSelector = document.getElementById(`tourVehicleSelector_${dayIndex}_${subconceptIndex}`);
                        if (vehicleSelector) {
                            vehicleSelector.innerHTML = '<option value="">Primero seleccione un destino</option>';
                            vehicleSelector.disabled = true;
                        }

                        initTourDestinationSelector(dayIndex, subconceptIndex, subconcept, rateId);
                        renderDay(dayIndex);
                        markDirty();
                        triggerAutoSave();
                    }
                } else {
                    // Rate deselected - clear everything
                    subconcept.rateId = null;
                    subconcept.rateName = "";
                    subconcept.destinationId = null;
                    subconcept.destinationPOI = "";
                    subconcept.tourId = null;
                    subconcept.vehicleTypeId = null;
                    subconcept.vehicleType = "";
                    subconcept.durationMinutes = 0;
                    subconcept.unitPrice = 0;
                    subconcept.total = 0;

                    const destinationSelector = document.getElementById(`tourDestinationSelector_${dayIndex}_${subconceptIndex}`);
                    if (destinationSelector) {
                        if (destinationSelector.tomselect) {
                            destinationSelector.tomselect.destroy();
                        }
                        destinationSelector.innerHTML = '<option value="">Primero seleccione tarifa...</option>';
                        destinationSelector.disabled = true;
                    }

                    const vehicleSelector = document.getElementById(`tourVehicleSelector_${dayIndex}_${subconceptIndex}`);
                    if (vehicleSelector) {
                        vehicleSelector.innerHTML = '<option value="">Primero seleccione tarifa...</option>';
                        vehicleSelector.disabled = true;
                    }

                    renderDay(dayIndex);
                    markDirty();
                    triggerAutoSave();
                }
            };

            // If rate already selected, enable destination selector
            if (subconcept.rateId) {
                const destinationSelector = document.getElementById(`tourDestinationSelector_${dayIndex}_${subconceptIndex}`);
                if (destinationSelector) {
                    destinationSelector.disabled = false;
                }
                initTourDestinationSelector(dayIndex, subconceptIndex, subconcept, subconcept.rateId);
            } else {
                // No rate selected, make sure vehicle selector is disabled
                const vehicleSelector = document.getElementById(`tourVehicleSelector_${dayIndex}_${subconceptIndex}`);
                if (vehicleSelector) {
                    vehicleSelector.disabled = true;
                }
            }
        });
    }

    /**
     * Initialize tour destination selector based on selected rate
     * Step 2 of 3: Destination selection
     */
    function initTourDestinationSelector(dayIndex, subconceptIndex, subconcept, rateId) {
        const destinationSelector = document.getElementById(`tourDestinationSelector_${dayIndex}_${subconceptIndex}`);
        if (!destinationSelector) {
            console.error('Tour destination selector not found');
            return;
        }

        // Get the day's date for availability filtering
        const dayData = serviceItemsData.days[dayIndex];
        const dayDate = dayData ? dayData.dayDate : null;
        
        console.log(`üèõÔ∏è Loading tour destinations for rate ${rateId} filtered by date: ${dayDate || 'all dates'}`);

        // Show loading message
        destinationSelector.innerHTML = '<option value="">Cargando destinos...</option>';
        destinationSelector.disabled = true;

        // Load destinations for this rate filtered by date
        loadTourDestinationsByRate(rateId, dayDate).then(destinations => {
            // Destroy existing TomSelect if any
            if (destinationSelector.tomselect) {
                destinationSelector.tomselect.destroy();
            }

            // Clear options
            destinationSelector.innerHTML = '<option value="">Seleccionar destino...</option>';

            if (destinations.length === 0) {
                destinationSelector.innerHTML = '<option value="">No hay destinos para esta tarifa</option>';
                destinationSelector.disabled = true;
                return;
            }

            // Enable selector
            destinationSelector.disabled = false;

            // Add destinations to selector
            destinations.forEach(dest => {
                const option = document.createElement('option');
                option.value = dest.destinationId;
                option.textContent = dest.destinationName;
                if (subconcept.destinationId === dest.destinationId) {
                    option.selected = true;
                }
                destinationSelector.appendChild(option);
            });

            // Initialize TomSelect with search
            const tomSelectInstance = new TomSelect(destinationSelector, {
                create: false,
                sortField: { field: 'text', direction: 'asc' },
                placeholder: 'Seleccionar destino...',
                allowEmptyOption: true
            });

            // If there's a saved destination, load vehicles for it
            if (subconcept.destinationId) {
                updateTourVehicleSelector(dayIndex, subconceptIndex, subconcept, rateId, subconcept.destinationId);
            }

            // Handle destination change
            destinationSelector.onchange = function(e) {
                const destinationId = e.target.value;

                if (destinationId) {
                    // Store destination info
                    const selectedDestination = destinations.find(d => d.destinationId === destinationId);
                    subconcept.destinationId = destinationId;
                    subconcept.destinationPOI = selectedDestination ? selectedDestination.destinationName : '';
                    // For tours, set concept to destination name for display
                    subconcept.concept = selectedDestination ? selectedDestination.destinationName : 'Tour';

                    // Clear vehicle selection
                    subconcept.tourId = null;
                    subconcept.vehicleTypeId = null;
                    subconcept.vehicleType = "";
                    subconcept.durationMinutes = 0;
                    subconcept.unitPrice = 0;
                    subconcept.total = 0;

                    // Clear vehicle selector
                    const vehicleSelector = document.getElementById(`tourVehicleSelector_${dayIndex}_${subconceptIndex}`);
                    if (vehicleSelector) {
                        vehicleSelector.innerHTML = '<option value="">Seleccionar veh√≠culo...</option>';
                        vehicleSelector.disabled = false;
                    }

                    updateTourVehicleSelector(dayIndex, subconceptIndex, subconcept, rateId, destinationId);
                    renderDay(dayIndex);
                } else {
                    // Destination deselected
                    subconcept.destinationId = null;
                    subconcept.destinationPOI = "";
                    subconcept.tourId = null;
                    subconcept.vehicleTypeId = null;
                    subconcept.vehicleType = "";
                    subconcept.durationMinutes = 0;
                    subconcept.unitPrice = 0;
                    subconcept.total = 0;

                    const vehicleSelector = document.getElementById(`tourVehicleSelector_${dayIndex}_${subconceptIndex}`);
                    if (vehicleSelector) {
                        vehicleSelector.innerHTML = '<option value="">Primero seleccione un destino</option>';
                        vehicleSelector.disabled = true;
                    }

                    renderDay(dayIndex);
                }
            };
        }).catch(error => {
            console.error(`‚ùå Error loading tour destinations for rate ${rateId}:`, error);
            console.error('   Stack:', error.stack);
            destinationSelector.innerHTML = '<option value="">Error al cargar destinos - Ver consola</option>';
            destinationSelector.disabled = true;
            
            // Show user-friendly error
            const errorMessage = error.message || 'Error desconocido';
            showAlert('servicesAlerts', `Error al cargar destinos de tours: ${errorMessage}`, 'danger');
        });
    }

    /**
     * Load tour destinations filtered by rate and optionally by date availability
     * Returns unique destinations that have tours for the specified rate (and date if provided)
     * Uses caching to prevent rate limiting issues
     */
    async function loadTourDestinationsByRate(rateId, dayDate = null) {
        try {
            // Validate rate ID
            if (!rateId) {
                console.error('No rate ID provided for tour destinations');
                return [];
            }
            
            // Create cache key
            const cacheKey = `${rateId}_${dayDate || 'all'}`;
            const now = Date.now();
            
            // Check cache first
            if (tourDataCache.destinations.has(cacheKey)) {
                const cached = tourDataCache.destinations.get(cacheKey);
                if (now - cached.timestamp < tourDataCache.cacheTimeout) {
                    console.log(`üöÄ Using cached tour destinations for rate ${rateId}, date: ${dayDate || 'all'}`);
                    return cached.data;
                }
                // Cache expired, remove it
                tourDataCache.destinations.delete(cacheKey);
            }
            
            // Build URL with optional date parameter
            let url = `/api/quotes/tours/destinations-by-rate/${rateId}`;
            if (dayDate) {
                url += `?dayDate=${encodeURIComponent(dayDate)}`;
            }
            
            console.log(`üåê Fetching tour destinations from API for rate ${rateId}, date: ${dayDate || 'all'}`);
            
            // Add timeout to prevent infinite loading
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
            }, 30000); // 30 second timeout
            
            const response = await fetchWithRetry(url, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${getAccessToken()}`,
                    'Content-Type': 'application/json'
                },
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);

            // Check if response is ok first
            if (!response.ok) {
                const errorText = await response.text();
                console.error(`HTTP Error ${response.status}: ${errorText}`);
                throw new Error(`HTTP ${response.status}: ${response.statusText || 'Request failed'}`);
            }

            const result = await response.json();

            if (result.success && result.data) {
                // Cache the result
                tourDataCache.destinations.set(cacheKey, {
                    data: result.data,
                    timestamp: now
                });
                
                console.log(`‚úÖ Successfully loaded ${result.data.length} tour destinations for rate ${rateId}`);
                return result.data;
            } else {
                const errorMsg = result.error || 'Unknown error from API';
                console.error('API returned error:', errorMsg);
                throw new Error(`API Error: ${errorMsg}`);
            }
        } catch (error) {
            console.error('Error loading tour destinations:', error);
            showAlert('servicesAlerts', 'Error al cargar destinos de tours', 'danger');
            return [];
        }
    }

    /**
     * Load tour vehicles filtered by rate AND destination and optionally by date availability
     * Returns vehicles available for the specified rate + destination combination (and date if provided)
     * Uses caching to prevent rate limiting issues
     */
    async function loadTourVehiclesByRateAndDestination(rateId, destinationId, dayDate = null) {
        try {
            // Create cache key including numberOfPeople for accurate caching
            const cacheKey = `${rateId}_${destinationId}_${dayDate || 'all'}_${quoteNumberOfPeople}`;
            const now = Date.now();
            
            // Check cache first
            if (tourDataCache.vehicles.has(cacheKey)) {
                const cached = tourDataCache.vehicles.get(cacheKey);
                if (now - cached.timestamp < tourDataCache.cacheTimeout) {
                    console.log(`üöÄ Using cached tour vehicles for rate ${rateId}, destination ${destinationId}, date: ${dayDate || 'all'}`);
                    return cached.data;
                }
                // Cache expired, remove it
                tourDataCache.vehicles.delete(cacheKey);
            }
            
            // Build URL with numberOfPeople and optional date parameter
            let url = `/api/quotes/tours/vehicles-by-rate-destination/${rateId}/${destinationId}?numberOfPeople=${quoteNumberOfPeople}`;
            if (dayDate) {
                url += `&dayDate=${encodeURIComponent(dayDate)}`;
            }
            
            console.log(`üåê Fetching tour vehicles from API for rate ${rateId}, destination ${destinationId}, date: ${dayDate || 'all'}`);
            
            const response = await fetchWithRetry(url, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${getAccessToken()}`,
                    'Content-Type': 'application/json'
                }
            });

            const result = await response.json();

            if (result.success && result.data) {
                // Cache the result
                tourDataCache.vehicles.set(cacheKey, {
                    data: result.data,
                    timestamp: now
                });

                // Check if any vehicles available
                if (result.data.length === 0 && quoteNumberOfPeople > 0) {
                    showAlert('servicesAlerts',
                        `No hay veh√≠culos disponibles para este tour con capacidad para ${quoteNumberOfPeople} personas. Por favor seleccione otro destino o reduzca el n√∫mero de personas.`,
                        'warning');
                }

                return result.data;
            } else {
                console.error('Error loading tour vehicles:', result.error);
                return [];
            }
        } catch (error) {
            console.error('Error loading tour vehicles:', error);
            showAlert('servicesAlerts', 'Error al cargar veh√≠culos de tours', 'danger');
            return [];
        }
    }

    /**
     * Update tour vehicle selector based on rate and destination
     * Step 3 of 3: Vehicle selection
     */
    function updateTourVehicleSelector(dayIndex, subconceptIndex, subconcept, rateId, destinationId) {
        const vehicleSelector = document.getElementById(`tourVehicleSelector_${dayIndex}_${subconceptIndex}`);
        if (!vehicleSelector) {
            console.error('Tour vehicle selector not found');
            return;
        }

        // Get the day's date for availability filtering
        const dayData = serviceItemsData.days[dayIndex];
        const dayDate = dayData ? dayData.dayDate : null;
        
        console.log(`üöó Loading tour vehicles for rate ${rateId}, destination ${destinationId}, filtered by date: ${dayDate || 'all dates'}`);

        // Show loading message
        vehicleSelector.innerHTML = '<option value="">Cargando veh√≠culos...</option>';
        vehicleSelector.disabled = true;

        // Load vehicles for this rate + destination filtered by date
        loadTourVehiclesByRateAndDestination(rateId, destinationId, dayDate).then(vehicles => {
            console.log(`üöó Tour vehicle selector update: Found ${vehicles.length} vehicles for rate ${rateId}, destination ${destinationId}`);
            
            if (vehicles.length === 0) {
                vehicleSelector.innerHTML = '<option value="">No hay veh√≠culos disponibles</option>';
                vehicleSelector.disabled = true;
                console.log(`   ‚ö†Ô∏è No vehicles available - selector disabled`);
                return;
            }

            // Clear options
            vehicleSelector.innerHTML = '<option value="">Seleccionar veh√≠culo...</option>';

            // Enable selector
            vehicleSelector.disabled = false;
            console.log(`   ‚úÖ Vehicle selector enabled with ${vehicles.length} options`);

            // Add vehicle options (solo tipo de veh√≠culo, sin TomSelect)
            vehicles.forEach(vehicle => {
                const option = document.createElement('option');
                option.value = vehicle.tourId;  // Use tourId as value
                option.textContent = vehicle.vehicleType;  // Solo el tipo de veh√≠culo

                // Store all vehicle data as JSON for later use
                option.dataset.vehicleData = JSON.stringify(vehicle);

                // Pre-select if this matches saved data
                if (subconcept.tourId === vehicle.tourId && subconcept.vehicleTypeId === vehicle.vehicleTypeId) {
                    option.selected = true;
                }

                vehicleSelector.appendChild(option);
            });

            // Check if we have a pre-selected vehicle and populate pricing data
            const preSelectedOption = vehicleSelector.querySelector('option[selected]');
            if (preSelectedOption && preSelectedOption.dataset.vehicleData) {
                const vehicleData = JSON.parse(preSelectedOption.dataset.vehicleData);
                console.log(`üèóÔ∏è Populating tour pricing data for pre-selected vehicle: ${vehicleData.vehicleType}`);
                populateTourData(dayIndex, subconceptIndex, subconcept, vehicleData, true);
            }

            // Handle vehicle selection change
            vehicleSelector.onchange = function(e) {
                const selectedOption = e.target.selectedOptions[0];
                if (selectedOption && selectedOption.dataset.vehicleData) {
                    const vehicleData = JSON.parse(selectedOption.dataset.vehicleData);
                    populateTourData(dayIndex, subconceptIndex, subconcept, vehicleData);
                } else {
                    // Clear vehicle data
                    subconcept.tourId = null;
                    subconcept.vehicleTypeId = null;
                    subconcept.vehicleType = "";
                    subconcept.durationMinutes = 0;
                    subconcept.unitPrice = 0;
                    subconcept.total = 0;

                    renderDay(dayIndex);
                    markDirty();
                    triggerAutoSave();
                }
            };
        }).catch(error => {
            console.error('Error updating tour vehicle selector:', error);
            vehicleSelector.innerHTML = '<option value="">Error al cargar veh√≠culos</option>';
            vehicleSelector.disabled = true;
        });
    }

    /**
     * Populate subconcept with selected tour vehicle data
     */
    function populateTourData(dayIndex, subconceptIndex, subconcept, vehicleData = null, isInitialization = false) {
        // If vehicleData not provided, try to find it from current selection
        if (!vehicleData && subconcept.tourId && subconcept.vehicleTypeId) {
            const vehicleSelector = document.getElementById(`tourVehicleSelector_${dayIndex}_${subconceptIndex}`);
            if (vehicleSelector) {
                const selectedOption = Array.from(vehicleSelector.options).find(
                    opt => opt.dataset.vehicleData
                );
                if (selectedOption) {
                    vehicleData = JSON.parse(selectedOption.dataset.vehicleData);
                }
            }
        }

        if (!vehicleData) {
            console.warn('No vehicle data available to populate');
            return;
        }

        // Populate subconcept fields with tour data
        subconcept.tourId = vehicleData.tourId;
        subconcept.vehicleTypeId = vehicleData.vehicleTypeId;
        subconcept.vehicleType = vehicleData.vehicleType;
        subconcept.vehicleCapacity = vehicleData.capacity;
        subconcept.vehiclePassengerCapacity = vehicleData.capacity || null; // NEW - Passenger capacity for display
        subconcept.vehicleTrunkCapacity = vehicleData.trunkCapacity || null; // NEW - Trunk capacity for display
        subconcept.durationMinutes = vehicleData.durationMinutes;
        
        // Ensure concept is set to destination name for tours (if not already set)
        if (!subconcept.concept && subconcept.destinationPOI) {
            subconcept.concept = subconcept.destinationPOI;
        }

        // Precio unitario: usar el precio base (efectivo) del tour
        subconcept.unitPrice = vehicleData.basePrice;
        subconcept.basePrice = vehicleData.basePrice;
        subconcept.surcharge = vehicleData.surcharge;
        subconcept.surchargePercentage = vehicleData.surchargePercentage;


        // Calculate vehicle multiplier based on numberOfPeople and capacity
        const numberOfPeople = subconcept.numberOfPeople || quoteNumberOfPeople;
        subconcept.vehicleMultiplier = Math.ceil(numberOfPeople / vehicleData.capacity);

        // Calculate total: unitPrice √ó vehicleMultiplier
        subconcept.total = calculateSubconceptTotal(subconcept);

        console.log('Populated tour data:', {
            tourId: subconcept.tourId,
            destination: subconcept.destinationPOI,
            vehicleType: subconcept.vehicleType,
            capacity: subconcept.vehicleCapacity,
            durationMinutes: subconcept.durationMinutes,
            basePrice: subconcept.basePrice,
            surcharge: subconcept.surcharge,
            unitPrice: subconcept.unitPrice,
            numberOfPeople,
            vehicleMultiplier: subconcept.vehicleMultiplier,
            total: subconcept.total
        });

        // Re-render day to show updated data (skip during initialization to prevent loops)
        if (!isInitialization) {
            renderDay(dayIndex);
            recalculateDayTotal(dayIndex);
            recalculateGeneralTotals();
            markDirty();
            triggerAutoSave();
        } else {
            // During initialization, just recalculate without re-rendering to prevent loops
            recalculateDayTotal(dayIndex);
            recalculateGeneralTotals();
            // Update unit price display even during initialization
            updateUnitPriceDisplay(dayIndex, subconceptIndex, subconcept);
        }
    }

    // ============================================================
    // END TOUR SELECTOR FUNCTIONS
    // ============================================================

    function initExperienceSelector(dayIndex, subconceptIndex, subconcept) {
        const startTime = Date.now();
        const selectElement = document.getElementById(`experienceSelector_${dayIndex}_${subconceptIndex}`);
        
        console.log(`üéØ [${startTime}] Initializing experience selector for day ${dayIndex + 1}, subconcept ${subconceptIndex}`);
        
        if (!selectElement) {
            console.error(`   ‚ùå Experience selector element not found: experienceSelector_${dayIndex}_${subconceptIndex}`);
            return;
        }

        // Get the day's date to filter experiences by availability
        const dayData = serviceItemsData.days[dayIndex];
        const dayDate = dayData ? dayData.dayDate : null;
        
        console.log(`   üìÖ Day data: ${JSON.stringify({dayIndex, dayDate, hasSubconcept: !!subconcept, experienceId: subconcept?.experienceId})}`);
        
        // Check if element already has TomSelect initialized
        if (selectElement.tomselect) {
            console.log(`   üîÑ Element already has TomSelect, destroying first`);
            selectElement.tomselect.destroy();
        }
        
        // Load experiences filtered by day availability
        loadAvailableExperiences(dayDate)
            .then(experiences => {
                const loadTime = Date.now() - startTime;
                console.log(`   üìã [+${loadTime}ms] Loaded ${experiences.length} experiences for initialization`);
                
                // Check if element still exists (might be removed during async operation)
                const currentElement = document.getElementById(`experienceSelector_${dayIndex}_${subconceptIndex}`);
                if (!currentElement) {
                    console.log(`   ‚ö†Ô∏è  Element disappeared during async load - aborting`);
                    return;
                }
                
                if (experiences.length === 0) {
                    currentElement.innerHTML = '<option value="">No hay experiencias disponibles</option>';
                    console.log(`   ‚ö†Ô∏è  No experiences available for initialization`);
                    return;
                }

                // Clear existing options
                currentElement.innerHTML = '<option value="">Seleccionar experiencia...</option>';
                console.log(`   üßπ Cleared existing options`);

                // Add experience options (only name)
                let optionsAdded = 0;
                let preSelectedFound = false;
                let preSelectedExperience = null;
                
                experiences.forEach(experience => {
                    const option = document.createElement('option');
                    option.value = experience.id;
                    option.textContent = experience.name;

                    // Pre-select if this matches the current experienceId
                    if (subconcept.experienceId === experience.id) {
                        option.selected = true;
                        preSelectedFound = true;
                        preSelectedExperience = experience;
                        console.log(`   üéØ Pre-selecting experience: ${experience.name} (${experience.id})`);
                    }

                    currentElement.appendChild(option);
                    optionsAdded++;
                });
                
                console.log(`   ‚úÖ Added ${optionsAdded} options to select element, pre-selected: ${preSelectedFound}`);
                
                // If we have a pre-selected experience but it wasn't found in the available experiences,
                // this indicates a data consistency issue or filtering problem
                if (subconcept.experienceId && !preSelectedFound) {
                    console.warn(`   ‚ö†Ô∏è  Pre-selected experience ID "${subconcept.experienceId}" not found in available experiences!`);
                    console.log(`      Available experience IDs:`, experiences.map(exp => exp.id));
                    console.log(`      Subconcept data:`, {
                        experienceId: subconcept.experienceId,
                        experienceName: subconcept.experienceName,
                        concept: subconcept.concept
                    });
                }

                // Initialize Tom Select
                try {
                    const tomSelectInstance = new TomSelect(currentElement, {
                        placeholder: 'Buscar experiencia...',
                        maxOptions: 1000,
                        searchField: ['text'],
                        sortField: 'text',
                        closeAfterSelect: true,
                        onChange: function(experienceId) {
                            console.log(`   üîÑ Experience changed: ${experienceId}`);
                            if (experienceId) {
                                populateExperienceData(dayIndex, subconceptIndex, experienceId);
                            } else {
                                // Clear experience data when no experience is selected
                                clearExperienceData(dayIndex, subconceptIndex);
                            }
                        }
                    });
                    
                    const totalTime = Date.now() - startTime;
                    console.log(`   ‚úÖ [+${totalTime}ms] TomSelect initialized successfully`);
                    
                } catch (error) {
                    console.error(`   ‚ùå Error initializing TomSelect:`, error);
                }

                // Note: Don't auto-populate on init - data is already in subconcept
                // Repopulation only happens on user selection via onChange event
                
                // However, if this is a package experience with existing data, render the package table
                if (subconcept.isPackage && subconcept.includedExperiences && subconcept.includedExperiences.length > 0) {
                    console.log(`   üì¶ Rendering existing package table for experience: ${subconcept.experienceName}`);
                    renderExperiencePackageTable(dayIndex, subconceptIndex, subconcept.includedExperiences);
                }
            })
            .catch(error => {
                const errorTime = Date.now() - startTime;
                console.error(`   ‚ùå [+${errorTime}ms] Error during experience loading:`, error);
            });
    }

    function clearExperienceData(dayIndex, subconceptIndex) {
        const subconcept = serviceItemsData.days[dayIndex]?.subconcepts[subconceptIndex];
        if (!subconcept) return;

        // Clear experience data
        subconcept.experienceId = null;
        subconcept.experienceName = '';
        subconcept.concept = '';
        subconcept.unitPrice = 0;
        subconcept.total = 0;

        // Recalculate totals
        calculateSubconceptTotal(subconcept);
        recalculateDayTotal(dayIndex);
        recalculateGeneralTotals();

        // Mark as dirty for saving
        markDirty();

        // Re-render the row to update the display
        renderDay(dayIndex);
    }

    async function populateExperienceData(dayIndex, subconceptIndex, experienceId) {
        const subconcept = serviceItemsData.days[dayIndex]?.subconcepts[subconceptIndex];
        if (!subconcept) return;

        try {
            console.log(`Loading experience details for ID: ${experienceId}`);
            const response = await fetch(`/api/experiences/${experienceId}`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${getAccessToken()}`,
                    'Content-Type': 'application/json'
                }
            });

            const result = await response.json();

            if (result.success && result.data) {
                const experience = result.data;

                // Update subconcept data
                subconcept.experienceId = experience.id;
                subconcept.experienceName = experience.name;
                subconcept.concept = experience.name;
                subconcept.unitPrice = experience.cost || 0;
                subconcept.total = subconcept.unitPrice;

                // Save vehicle type if available
                if (experience.vehicleType) {
                    subconcept.vehicleType = experience.vehicleType.name;
                    subconcept.vehicleTypeId = experience.vehicleType.id;
                    subconcept.vehicleCapacity = experience.vehicleType.defaultCapacity;
                } else {
                    subconcept.vehicleType = null;
                    subconcept.vehicleTypeId = null;
                    subconcept.vehicleCapacity = null;
                }

                // Check if it's a package (has nested experiences)
                const hasIncluded = experience.experienceDetails && experience.experienceDetails.length > 0;
                subconcept.isPackage = hasIncluded;
                subconcept.includedExperiences = hasIncluded ? experience.experienceDetails : [];

                // Update UI fields directly without full re-render to avoid infinite loop
                        const priceInput = document.querySelector(`input[data-day-index="${dayIndex}"][data-subconcept-index="${subconceptIndex}"][data-field="unitPrice"]`);

                        if (priceInput) {
            // For readonly fields (traslado, tour, experiencia), just show the unitPrice
            // For editable fields (regular/service), also just show the unitPrice (no cash payment logic here)
            priceInput.value = formatCurrency(subconcept.unitPrice);
        }

                // Update vehicle type display if exists
                const vehicleCell = document.querySelector(`tr[data-day-index="${dayIndex}"][data-subconcept-index="${subconceptIndex}"] td:nth-child(3)`);
                if (vehicleCell) {
                    if (subconcept.vehicleType) {
                        vehicleCell.innerHTML = `
                            <div class="form-control form-control-sm bg-light" style="cursor: not-allowed;">
                                <i class="ti ti-car me-1 text-muted"></i>
                                <span>${subconcept.vehicleType}</span>
                            </div>
                        `;
                    } else {
                        vehicleCell.innerHTML = '<span class="badge bg-secondary">N/A</span>';
                    }
                }

                // Show/hide package table
                if (hasIncluded) {
                    renderExperiencePackageTable(dayIndex, subconceptIndex, experience.experienceDetails, experience);
                } else {
                    // Hide package table if not a package
                    const packageTableContainer = document.getElementById(`experiencePackageTable_${dayIndex}_${subconceptIndex}`);
                    if (packageTableContainer) {
                        packageTableContainer.style.display = 'none';
                    }
                }

                // Update unit price display immediately
                updateUnitPriceDisplay(dayIndex, subconceptIndex, subconcept);
                
                // Recalculate totals
                recalculateDayTotal(dayIndex);
                recalculateGeneralTotals();

                markDirty();
                triggerAutoSave();

                console.log('Experience data populated:', subconcept);
            }
        } catch (error) {
            console.error('Error loading experience details:', error);
            showAlert('servicesAlerts', 'Error al cargar los detalles de la experiencia', 'danger');
        }
    }

    function renderExperiencePackageTable(dayIndex, subconceptIndex, includedExperiences) {
        const packageTableContainer = document.getElementById(`experiencePackageTable_${dayIndex}_${subconceptIndex}`);
        if (!packageTableContainer || !includedExperiences || includedExperiences.length === 0) return;

        // Build list items for each included experience
        let listItems = '';
        includedExperiences.forEach((exp, index) => {
            const description = exp.description || '';
            listItems += `
                <li class="mb-2">
                    <div class="d-flex align-items-start">
                        <i class="ti ti-circle-check text-success me-2 mt-1" style="font-size: 0.875rem;"></i>
                        <div>
                            <strong class="d-block" style="font-size: 0.875rem;">${exp.name}</strong>
                            ${description ? `<small class="text-muted d-block mt-1" style="font-size: 0.75rem;">${description}</small>` : ''}
                        </div>
                    </div>
                </li>
            `;
        });

        // Build simple list HTML
        const listHTML = `
            <div class="alert alert-info border-info mb-0" style="background-color: rgba(13, 202, 240, 0.05);">
                <div class="d-flex align-items-center mb-2">
                    <i class="ti ti-package me-2"></i>
                    <strong style="font-size: 0.875rem;">Incluye ${includedExperiences.length} experiencia${includedExperiences.length !== 1 ? 's' : ''}:</strong>
                </div>
                <ul class="mb-0 ps-3" style="list-style: none;">
                    ${listItems}
                </ul>
            </div>
        `;

        packageTableContainer.innerHTML = listHTML;
        packageTableContainer.style.display = 'block';
    }

    /**
     * Migrate old quote structure (quote-level rate) to new structure (subconcept-level rate)
     * Called when loading service items to ensure backward compatibility
     */
    function migrateQuoteRateToSubconcepts(quote) {
        // If quote has a rate and service items, migrate rate to traslado subconcepts
        if (quote.rate && quote.serviceItems && quote.serviceItems.days) {
            const quoteRateId = quote.rate.id;
            const quoteRateName = quote.rate.name;

            console.log('Migrating quote-level rate to subconcepts:', {
                rateId: quoteRateId,
                rateName: quoteRateName
            });

            quote.serviceItems.days.forEach((day, dayIndex) => {
                if (!day.subconcepts) return;

                day.subconcepts.forEach((sub, subIndex) => {
                    if (sub.type === 'traslado' && !sub.rateId) {
                        // Migrate: Set quote's rate to this traslado
                        sub.rateId = quoteRateId;
                        sub.rateName = quoteRateName;
                        console.log(`Migrated rate to day ${dayIndex + 1}, subconcept ${subIndex + 1}`);
                    }
                });
            });
        }

        return quote;
    }

    function migrateSubconceptToTyped(subconcept) {
        // Always update numberOfPeople if it's 1 and should be quoteNumberOfPeople
        // This handles cases where old data has numberOfPeople: 1 by default
        const migratedNumberOfPeople = (subconcept.numberOfPeople === 1 && quoteNumberOfPeople > 1)
            ? quoteNumberOfPeople
            : (subconcept.numberOfPeople || quoteNumberOfPeople);

        // If already has type, update numberOfPeople if needed
        if (subconcept.type) {
            const migrated = {
                ...subconcept,
                numberOfPeople: migratedNumberOfPeople
            };
            
            // Ensure capacity fields are populated for transfers/tours with vehicles
            if ((subconcept.type === 'traslado' || subconcept.type === 'tour') && subconcept.vehicleTypeId) {
                if (migrated.vehiclePassengerCapacity === undefined && subconcept.vehicleCapacity) {
                    migrated.vehiclePassengerCapacity = subconcept.vehicleCapacity;
                }
                if (migrated.vehicleTrunkCapacity === undefined) {
                    migrated.vehicleTrunkCapacity = null; // Will show as N/D in UI
                }
            }
            
            return migrated;
        }


        // Otherwise, treat as "regular" type
        return {
            type: "regular",
            time: subconcept.time || "",
            concept: subconcept.concept || "",
            vehicleType: subconcept.vehicleType || "N/A",
            unitPrice: subconcept.unitPrice ?? 0,
            total: subconcept.total || 0,
            notes: subconcept.notes || "",
            numberOfPeople: migratedNumberOfPeople,
            vehicleCapacity: null,
            vehicleMultiplier: 1,
            isCashPayment: subconcept.isCashPayment !== undefined ? subconcept.isCashPayment : false
        };
    }

    // ==================
    // CRUD OPERATIONS
    // ==================

    function addDay() {
        const newDay = {
            dayNumber: serviceItemsData.days.length + 1,
            dayTitle: "",
            dayDate: "",  // Optional date field for the day
            subconcepts: [],
            dayTotal: 0
        };

        serviceItemsData.days.push(newDay);
        renderDay(serviceItemsData.days.length - 1, true);

        // Show table if it was hidden
        const emptyState = document.getElementById('emptyState');
        const tableContainer = document.getElementById('servicesTableContainer');
        if (emptyState && tableContainer) {
            emptyState.classList.remove('d-flex');
            emptyState.classList.add('d-none');
            tableContainer.classList.remove('d-none');
            tableContainer.classList.add('d-block');
        }

        markDirty();
        triggerAutoSave();
    }

    function updateDayField(dayIndex, field, value) {
        if (!serviceItemsData.days[dayIndex]) return;

        serviceItemsData.days[dayIndex][field] = value;
        markDirty();
        triggerAutoSave();
    }

    function addSubconcept(dayIndex, type = 'regular') {
        if (!serviceItemsData.days[dayIndex]) return;

        const newSubconcept = {
            type: type,
            time: "",
            concept: "",
            vehicleType: type === "regular" ? "N/A" : (type === "experiencia" ? "N/A" : ""),
            unitPrice: 0,
            total: 0,
            notes: "",
            numberOfPeople: quoteNumberOfPeople, // Default to quote's number of people
            vehicleCapacity: null,
            vehicleMultiplier: 1,
            // Payment method fields
            isCashPayment: type === 'regular' ? true : false
        };

        // Additional fields for traslados
        if (type === "traslado") {
            newSubconcept.rateId = null;        // NEW - Rate must be selected first
            newSubconcept.rateName = "";        // NEW - Rate display name
            newSubconcept.transferId = null;
            newSubconcept.vehicleTypeId = null;
            newSubconcept.additionalVehicleForLuggage = false;  // NEW - Checkbox for extra vehicle
            newSubconcept.vehiclePassengerCapacity = null;      // NEW - Vehicle passenger capacity
            newSubconcept.vehicleTrunkCapacity = null;          // NEW - Vehicle trunk capacity
        }

        // Additional fields for experiencias
        if (type === "experiencia") {
            newSubconcept.experienceId = null;
            newSubconcept.experienceName = "";
            newSubconcept.isPackage = false;
            newSubconcept.includedExperiences = [];
        }

        // Additional fields for tours
        if (type === "tour") {
            newSubconcept.rateId = null;           // Step 1: Rate must be selected first
            newSubconcept.rateName = "";           // Rate display name
            newSubconcept.destinationId = null;    // Step 2: Destination ID (NEW)
            newSubconcept.destinationPOI = "";     // Step 2: Destination name
            newSubconcept.tourId = null;           // Step 3: Selected tour ID (specific rate+dest+vehicle combo)
            newSubconcept.vehicleTypeId = null;    // Step 3: Vehicle type ID
            newSubconcept.vehicleType = "";        // Step 3: Vehicle type name
            newSubconcept.durationMinutes = 0;     // Duration in minutes (from tour record)
            newSubconcept.additionalVehicleForLuggage = false;  // NEW - Checkbox for extra vehicle
            newSubconcept.vehiclePassengerCapacity = null;      // NEW - Vehicle passenger capacity
            newSubconcept.vehicleTrunkCapacity = null;          // NEW - Vehicle trunk capacity
        }

        serviceItemsData.days[dayIndex].subconcepts.push(newSubconcept);
        renderDay(dayIndex);
        markDirty();
        triggerAutoSave();
    }

    /**
     * Calculate subconcept total with per-person pricing logic
     * @param {Object} subconcept - The subconcept object
     * @returns {number} - Calculated total
     */
    function calculateSubconceptTotal(subconcept) {
        // Get the appropriate price based on cash payment checkbox
        const basePrice = parseFloat(subconcept.unitPrice) || 0;
        const surcharge = parseFloat(subconcept.surcharge) || (basePrice * 0.21);
        const unitPrice = subconcept.isCashPayment ? basePrice : basePrice + surcharge;
        const numberOfPeople = parseInt(subconcept.numberOfPeople) || 1;

        console.log('calculateSubconceptTotal called:', {
            type: subconcept.type,
            isCashPayment: subconcept.isCashPayment,
            basePrice: basePrice,
            surcharge: surcharge,
            unitPrice: unitPrice,
            numberOfPeople,
            vehicleCapacity: subconcept.vehicleCapacity,
            currentMultiplier: subconcept.vehicleMultiplier
        });

        // TRASLADO: Direct unit price multiplied by vehicle count (1 or 2 based on checkbox)
        if (subconcept.type === 'traslado' && subconcept.vehicleCapacity) {
            // Vehicle count: 1 by default, 2 if additional vehicle for luggage is checked
            const vehicleCount = subconcept.additionalVehicleForLuggage ? 2 : 1;
            console.log('Traslado vehicle calculation:', {
                numberOfPeople,
                vehicleCapacity: subconcept.vehicleCapacity,
                additionalVehicleForLuggage: subconcept.additionalVehicleForLuggage,
                vehicleCount,
                calculation: `$${unitPrice} √ó ${vehicleCount} vehicle(s) = $${unitPrice * vehicleCount}`
            });
            return Math.round(unitPrice * vehicleCount * 100) / 100;
        }

        // TOUR: Direct unit price multiplied by vehicle count (1 or 2 based on checkbox)
        if (subconcept.type === 'tour' && subconcept.vehicleCapacity) {
            // Vehicle count: 1 by default, 2 if additional vehicle for luggage is checked
            const vehicleCount = subconcept.additionalVehicleForLuggage ? 2 : 1;
            console.log('Tour vehicle calculation:', {
                numberOfPeople,
                vehicleCapacity: subconcept.vehicleCapacity,
                additionalVehicleForLuggage: subconcept.additionalVehicleForLuggage,
                vehicleCount,
                calculation: `$${unitPrice} √ó ${vehicleCount} vehicle(s) = $${unitPrice * vehicleCount}`
            });
            return Math.round(unitPrice * vehicleCount * 100) / 100;
        }

        // EXPERIENCIA: Direct unit price
        if (subconcept.type === 'experiencia') {
            console.log('Experiencia calculation:', {
                unitPrice,
                calculation: `$${unitPrice}`
            });
            return Math.round(unitPrice * 100) / 100;
        }

        // REGULAR: Direct unit price (same as experiencia)
        if (subconcept.type === 'regular') {
            console.log('Regular calculation:', {
                unitPrice,
                calculation: `$${unitPrice}`
            });
            return Math.round(unitPrice * 100) / 100;
        }

        // Fallback for traslados without vehicle capacity
        console.log('Fallback calculation (traslado without capacity)');
        subconcept.vehicleMultiplier = 1;
        return Math.round(unitPrice * 100) / 100;
    }

    function updateSubconceptField(dayIndex, subconceptIndex, field, value) {
        const subconcept = serviceItemsData.days[dayIndex]?.subconcepts[subconceptIndex];
        if (!subconcept) return;

        if (field === 'isCashPayment') {
            // Handle cash payment checkbox
            subconcept.isCashPayment = value === true || value === 'true' || value === 'on';
        } else {
            subconcept[field] = value;
        }

        // Recalculate total if any pricing field changed
        if (['unitPrice', 'numberOfPeople'].includes(field)) {
            subconcept.total = calculateSubconceptTotal(subconcept);

            // Update vehicle multiplier badge text if traslado or tour
            if (subconcept.type === 'traslado' || subconcept.type === 'tour') {
                const badge = document.querySelector(
                    `.vehicle-multiplier[data-day-index="${dayIndex}"][data-subconcept-index="${subconceptIndex}"]`
                );
                console.log('Updating badge:', {
                    badgeFound: !!badge,
                    vehicleMultiplier: subconcept.vehicleMultiplier,
                    vehicleCapacity: subconcept.vehicleCapacity,
                    vehicleTypeId: subconcept.vehicleTypeId
                });
                if (badge) {
                    // Update badge text with current multiplier
                    badge.textContent = `${subconcept.vehicleMultiplier || 1}x`;
                    console.log('Badge updated to:', badge.textContent);

                    // Update badge visibility
                    const hasVehicle = subconcept.vehicleCapacity || subconcept.vehicleTypeId;
                    badge.style.display = hasVehicle ? 'inline-block' : 'none';
                    console.log('Badge visibility:', badge.style.display);
                }
            }

            recalculateDayTotal(dayIndex);
            recalculateGeneralTotals();
        }

        markDirty();
        triggerAutoSave();
    }

    function recalculateDayTotal(dayIndex) {
        const day = serviceItemsData.days[dayIndex];
        if (!day) return;

        const dayTotal = day.subconcepts.reduce((sum, sub) => {
            return sum + (parseFloat(sub.total) || 0);
        }, 0);

        day.dayTotal = Math.round(dayTotal * 100) / 100;

        // Calculate per person cost
        const perPersonCost = quoteNumberOfPeople > 0 ? day.dayTotal / quoteNumberOfPeople : 0;

        // Update total display
        const totalDisplay = document.querySelector(`.day-total-display[data-day-index="${dayIndex}"]`);
        if (totalDisplay) {
            totalDisplay.textContent = currencyFormatter.format(day.dayTotal);

            totalDisplay.classList.add('text-success');
            setTimeout(() => {
                totalDisplay.classList.remove('text-success');
            }, 1000);
        }

        // Update per person display
        const perPersonDisplay = document.querySelector(`.day-per-person-display[data-day-index="${dayIndex}"]`);
        if (perPersonDisplay) {
            perPersonDisplay.textContent = currencyFormatter.format(perPersonCost);
        }

        // DO NOT recalculate general totals yet (as requested)
    }

    function recalculateGeneralTotals() {
        // Calculate subtotal from all day totals
        const subtotal = serviceItemsData.days.reduce((sum, day) => {
            return sum + (parseFloat(day.dayTotal) || 0);
        }, 0);

        // Calculate IVA (16%)
        const iva = subtotal * 0.16;

        // Calculate total
        const total = subtotal + iva;

        // Round to 2 decimals
        serviceItemsData.subtotal = Math.round(subtotal * 100) / 100;
        serviceItemsData.iva = Math.round(iva * 100) / 100;
        serviceItemsData.total = Math.round(total * 100) / 100;

        // Update display
        updateTotalsDisplay();
    }

    function recalculateAllDayTotals() {
        // Recalculate dayTotal for each day without updating display (for bulk operations)
        serviceItemsData.days.forEach((day, index) => {
            const dayTotal = day.subconcepts.reduce((sum, sub) => {
                return sum + (parseFloat(sub.total) || 0);
            }, 0);
            day.dayTotal = Math.round(dayTotal * 100) / 100;
        });
    }

    function removeDay(dayIndex) {
        if (!serviceItemsData.days[dayIndex]) return;

        serviceItemsData.days.splice(dayIndex, 1);
        renumberDays();
        renderTable();
        recalculateGeneralTotals();
        markDirty();
        triggerAutoSave();
    }

    function removeSubconcept(dayIndex, subconceptIndex) {
        const day = serviceItemsData.days[dayIndex];
        if (!day?.subconcepts[subconceptIndex]) return;

        day.subconcepts.splice(subconceptIndex, 1);
        recalculateDayTotal(dayIndex);
        recalculateGeneralTotals();
        renderDay(dayIndex);
        markDirty();
        triggerAutoSave();
    }

    function renumberDays() {
        serviceItemsData.days.forEach((day, index) => {
            day.dayNumber = index + 1;
        });
    }

    // ==================
    // MODALS
    // ==================

    function openDeleteDayModal(dayIndex) {
        deleteContext = { type: 'day', dayIndex, subconceptIndex: null };

        const dayNumber = serviceItemsData.days[dayIndex]?.dayNumber;
        const deleteDayText = document.getElementById('deleteDayText');
        if (deleteDayText) {
            deleteDayText.textContent = `D√≠a ${dayNumber}`;
        }

        const modal = new bootstrap.Modal(document.getElementById('deleteDayModal'));
        modal.show();
    }

    function confirmDeleteDay() {
        if (deleteContext.type === 'day' && deleteContext.dayIndex !== null) {
            removeDay(deleteContext.dayIndex);

            const modal = bootstrap.Modal.getInstance(document.getElementById('deleteDayModal'));
            if (modal) modal.hide();

            deleteContext = { type: null, dayIndex: null, subconceptIndex: null };
        }
    }

    function openDeleteSubconceptModal(dayIndex, subconceptIndex) {
        deleteContext = { type: 'subconcept', dayIndex, subconceptIndex };

        const subconcept = serviceItemsData.days[dayIndex]?.subconcepts[subconceptIndex];
        const deleteSubconceptText = document.getElementById('deleteSubconceptText');
        if (deleteSubconceptText && subconcept) {
            const time = subconcept.time || '(Sin hora)';
            const concept = subconcept.concept || '(Sin descripci√≥n)';
            deleteSubconceptText.textContent = `${time} - ${concept}`;
        }

        const modal = new bootstrap.Modal(document.getElementById('deleteSubconceptModal'));
        modal.show();
    }

    function confirmDeleteSubconcept() {
        if (deleteContext.type === 'subconcept' && deleteContext.dayIndex !== null && deleteContext.subconceptIndex !== null) {
            removeSubconcept(deleteContext.dayIndex, deleteContext.subconceptIndex);

            const modal = bootstrap.Modal.getInstance(document.getElementById('deleteSubconceptModal'));
            if (modal) modal.hide();

            deleteContext = { type: null, dayIndex: null, subconceptIndex: null };
        }
    }

    // ==================
    // AUTO-SAVE
    // ==================

    function triggerAutoSave() {
        if (saveTimeout) clearTimeout(saveTimeout);

        saveTimeout = setTimeout(() => {
            saveServiceItems();
        }, 2000);
    }

    async function saveServiceItems() {
        if (!isDirty || isNewQuote) return;

        showSaveIndicator('saving', 'Guardando...');
        clearAlerts('servicesAlerts');

        try {
            const response = await fetch(`/api/quotes/${quoteId}/service-items`, {
                method: 'PUT',
                headers: {
                    'Authorization': `Bearer ${getAccessToken()}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(serviceItemsData)
            });

            const result = await response.json();

            if (result.success) {
                markClean();
                showSaveIndicator('saved', 'Guardado');

                setTimeout(() => {
                    if (!isDirty) {
                        showSaveIndicator('idle', 'Sin cambios');
                    }
                }, 3000);
            } else {
                throw new Error(result.error || 'Error al guardar');
            }
        } catch (error) {
            console.error('Error saving service items:', error);
            showSaveIndicator('error', 'Error al guardar');
            showAlert('servicesAlerts', error.message || 'Error al guardar los servicios', 'danger');
        }
    }

    // ==================
    // INITIALIZATION
    // ==================

    document.addEventListener('DOMContentLoaded', async function() {
        const pageLoadStart = Date.now();
        console.log(`üåü [${pageLoadStart}] Page DOM loaded, starting initialization sequence`);
        
        try {
            console.log(`üìä Page state check:`, {
                quoteId,
                isNewQuote,
                hasServiceItemsData: !!serviceItemsData,
                currentUrl: window.location.href
            });
            
            await loadServiceItems();
            
            const initTime = Date.now() - pageLoadStart;
            console.log(`‚úÖ [+${initTime}ms] Service items loaded successfully`);
            
        } catch (error) {
            const errorTime = Date.now() - pageLoadStart;
            console.error(`‚ùå [+${errorTime}ms] Error during initialization:`, error);
        }

        // Add Day buttons (top and bottom)
        const addDayBtn = document.getElementById('addDayBtn');
        if (addDayBtn) {
            addDayBtn.addEventListener('click', addDay);
        }

        const addDayBtnBottom = document.getElementById('addDayBtnBottom');
        if (addDayBtnBottom) {
            addDayBtnBottom.addEventListener('click', addDay);
        }

        const confirmDeleteDayBtn = document.getElementById('confirmDeleteDayBtn');
        if (confirmDeleteDayBtn) {
            confirmDeleteDayBtn.addEventListener('click', confirmDeleteDay);
        }

        const confirmDeleteSubconceptBtn = document.getElementById('confirmDeleteSubconceptBtn');
        if (confirmDeleteSubconceptBtn) {
            confirmDeleteSubconceptBtn.addEventListener('click', confirmDeleteSubconcept);
        }

        window.addEventListener('beforeunload', (e) => {
            if (isDirty) {
                e.preventDefault();
                e.returnValue = '¬øDescartar cambios sin guardar?';
            }
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isDirty) {
                saveServiceItems();
            }
        });
    });
})();
</script>
